2023-02-20 22:15:45.893 EET [621446] LOG:  starting PostgreSQL 12.9 on x86_64-conda-linux-gnu, compiled by x86_64-conda-linux-gnu-cc (Anaconda gcc) 11.2.0, 64-bit
2023-02-20 22:15:45.893 EET [621446] LOG:  could not bind IPv6 address "::1": Address already in use
2023-02-20 22:15:45.893 EET [621446] HINT:  Is another postmaster already running on port 5432? If not, wait a few seconds and retry.
2023-02-20 22:15:45.893 EET [621446] LOG:  could not bind IPv4 address "127.0.0.1": Address already in use
2023-02-20 22:15:45.893 EET [621446] HINT:  Is another postmaster already running on port 5432? If not, wait a few seconds and retry.
2023-02-20 22:15:45.893 EET [621446] WARNING:  could not create listen socket for "localhost"
2023-02-20 22:15:45.893 EET [621446] FATAL:  could not create any TCP/IP sockets
2023-02-20 22:15:45.893 EET [621446] LOG:  database system is shut down
2023-02-20 22:16:56.508 EET [621931] LOG:  starting PostgreSQL 12.9 on x86_64-conda-linux-gnu, compiled by x86_64-conda-linux-gnu-cc (Anaconda gcc) 11.2.0, 64-bit
2023-02-20 22:16:56.509 EET [621931] LOG:  listening on IPv6 address "::1", port 5432
2023-02-20 22:16:56.509 EET [621931] LOG:  listening on IPv4 address "127.0.0.1", port 5432
2023-02-20 22:16:56.516 EET [621931] LOG:  listening on Unix socket "/tmp/.s.PGSQL.5432"
2023-02-20 22:16:56.566 EET [621932] LOG:  database system was shut down at 2023-02-20 22:15:28 EET
2023-02-20 22:16:56.576 EET [621931] LOG:  database system is ready to accept connections
2023-02-20 22:19:53.538 EET [622462] FATAL:  database "bob" does not exist
2023-02-20 22:20:04.264 EET [622487] FATAL:  role "bobDB" does not exist
2023-02-20 22:20:20.798 EET [622517] FATAL:  database "bob" does not exist
2023-02-20 22:20:45.186 EET [622599] FATAL:  database "javi" does not exist
2023-02-20 22:20:53.357 EET [622632] FATAL:  database "javi" does not exist
2023-02-20 22:20:56.757 EET [622659] FATAL:  database "bob" does not exist
2023-02-20 22:33:38.429 EET [629528] FATAL:  database "bob" does not exist
2023-02-20 22:38:12.927 EET [632084] WARNING:  there is no transaction in progress
2023-02-21 11:23:02.830 EET [632084] WARNING:  there is no transaction in progress
2023-02-21 11:24:07.262 EET [642046] FATAL:  database "bob" does not exist
2023-02-21 11:32:37.546 EET [643359] WARNING:  there is no transaction in progress
2023-02-21 12:10:52.220 EET [648184] WARNING:  there is no transaction in progress
2023-02-21 12:27:36.554 EET [649690] WARNING:  there is no transaction in progress
2023-02-21 13:07:27.661 EET [654348] ERROR:  syntax error at or near "use" at character 1
2023-02-21 13:07:27.661 EET [654348] STATEMENT:  use dvdrental;
2023-02-21 13:07:53.207 EET [654474] FATAL:  database "dvdrental" does not exist
2023-02-21 13:08:52.069 EET [654348] ERROR:  syntax error at or near "dvdrental" at character 8
2023-02-21 13:08:52.069 EET [654348] STATEMENT:  create dvdrental;
2023-02-21 13:16:48.367 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.367 EET [655626] STATEMENT:  ALTER TYPE public.mpaa_rating OWNER TO postgres;
	
	
2023-02-21 13:16:48.372 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.372 EET [655626] STATEMENT:  ALTER DOMAIN public.year OWNER TO postgres;
	
	
2023-02-21 13:16:48.377 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.377 EET [655626] STATEMENT:  ALTER FUNCTION public._group_concat(text, text) OWNER TO postgres;
	
	
2023-02-21 13:16:48.384 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.384 EET [655626] STATEMENT:  ALTER FUNCTION public.film_in_stock(p_film_id integer, p_store_id integer, OUT p_film_count integer) OWNER TO postgres;
	
	
2023-02-21 13:16:48.392 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.392 EET [655626] STATEMENT:  ALTER FUNCTION public.film_not_in_stock(p_film_id integer, p_store_id integer, OUT p_film_count integer) OWNER TO postgres;
	
	
2023-02-21 13:16:48.400 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.400 EET [655626] STATEMENT:  ALTER FUNCTION public.get_customer_balance(p_customer_id integer, p_effective_date timestamp without time zone) OWNER TO postgres;
	
	
2023-02-21 13:16:48.405 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.405 EET [655626] STATEMENT:  ALTER FUNCTION public.inventory_held_by_customer(p_inventory_id integer) OWNER TO postgres;
	
	
2023-02-21 13:16:48.409 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.409 EET [655626] STATEMENT:  ALTER FUNCTION public.inventory_in_stock(p_inventory_id integer) OWNER TO postgres;
	
	
2023-02-21 13:16:48.413 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.413 EET [655626] STATEMENT:  ALTER FUNCTION public.last_day(timestamp without time zone) OWNER TO postgres;
	
	
2023-02-21 13:16:48.417 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.417 EET [655626] STATEMENT:  ALTER FUNCTION public.last_updated() OWNER TO postgres;
	
	
2023-02-21 13:16:48.422 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.422 EET [655626] STATEMENT:  ALTER TABLE public.customer_customer_id_seq OWNER TO postgres;
	
	
2023-02-21 13:16:48.429 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.429 EET [655626] STATEMENT:  ALTER TABLE public.customer OWNER TO postgres;
	
	
2023-02-21 13:16:48.433 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.433 EET [655626] STATEMENT:  ALTER FUNCTION public.rewards_report(min_monthly_purchases integer, min_dollar_amount_purchased numeric) OWNER TO postgres;
	
	
2023-02-21 13:16:48.437 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.437 EET [655626] STATEMENT:  ALTER AGGREGATE public.group_concat(text) OWNER TO postgres;
	
	
2023-02-21 13:16:48.441 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.441 EET [655626] STATEMENT:  ALTER TABLE public.actor_actor_id_seq OWNER TO postgres;
	
	
2023-02-21 13:16:48.445 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.445 EET [655626] STATEMENT:  ALTER TABLE public.actor OWNER TO postgres;
	
	
2023-02-21 13:16:48.449 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.449 EET [655626] STATEMENT:  ALTER TABLE public.category_category_id_seq OWNER TO postgres;
	
	
2023-02-21 13:16:48.453 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.453 EET [655626] STATEMENT:  ALTER TABLE public.category OWNER TO postgres;
	
	
2023-02-21 13:16:48.457 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.457 EET [655626] STATEMENT:  ALTER TABLE public.film_film_id_seq OWNER TO postgres;
	
	
2023-02-21 13:16:48.466 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.466 EET [655626] STATEMENT:  ALTER TABLE public.film OWNER TO postgres;
	
	
2023-02-21 13:16:48.470 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.470 EET [655626] STATEMENT:  ALTER TABLE public.film_actor OWNER TO postgres;
	
	
2023-02-21 13:16:48.474 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.474 EET [655626] STATEMENT:  ALTER TABLE public.film_category OWNER TO postgres;
	
	
2023-02-21 13:16:48.480 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.480 EET [655626] STATEMENT:  ALTER TABLE public.actor_info OWNER TO postgres;
	
	
2023-02-21 13:16:48.484 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.484 EET [655626] STATEMENT:  ALTER TABLE public.address_address_id_seq OWNER TO postgres;
	
	
2023-02-21 13:16:48.488 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.488 EET [655626] STATEMENT:  ALTER TABLE public.address OWNER TO postgres;
	
	
2023-02-21 13:16:48.492 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.492 EET [655626] STATEMENT:  ALTER TABLE public.city_city_id_seq OWNER TO postgres;
	
	
2023-02-21 13:16:48.500 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.500 EET [655626] STATEMENT:  ALTER TABLE public.city OWNER TO postgres;
	
	
2023-02-21 13:16:48.503 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.503 EET [655626] STATEMENT:  ALTER TABLE public.country_country_id_seq OWNER TO postgres;
	
	
2023-02-21 13:16:48.508 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.508 EET [655626] STATEMENT:  ALTER TABLE public.country OWNER TO postgres;
	
	
2023-02-21 13:16:48.512 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.512 EET [655626] STATEMENT:  ALTER TABLE public.customer_list OWNER TO postgres;
	
	
2023-02-21 13:16:48.518 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.518 EET [655626] STATEMENT:  ALTER TABLE public.film_list OWNER TO postgres;
	
	
2023-02-21 13:16:48.522 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.522 EET [655626] STATEMENT:  ALTER TABLE public.inventory_inventory_id_seq OWNER TO postgres;
	
	
2023-02-21 13:16:48.526 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.526 EET [655626] STATEMENT:  ALTER TABLE public.inventory OWNER TO postgres;
	
	
2023-02-21 13:16:48.530 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.530 EET [655626] STATEMENT:  ALTER TABLE public.language_language_id_seq OWNER TO postgres;
	
	
2023-02-21 13:16:48.534 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.534 EET [655626] STATEMENT:  ALTER TABLE public.language OWNER TO postgres;
	
	
2023-02-21 13:16:48.540 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.540 EET [655626] STATEMENT:  ALTER TABLE public.nicer_but_slower_film_list OWNER TO postgres;
	
	
2023-02-21 13:16:48.544 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.544 EET [655626] STATEMENT:  ALTER TABLE public.payment_payment_id_seq OWNER TO postgres;
	
	
2023-02-21 13:16:48.548 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.548 EET [655626] STATEMENT:  ALTER TABLE public.payment OWNER TO postgres;
	
	
2023-02-21 13:16:48.553 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.553 EET [655626] STATEMENT:  ALTER TABLE public.rental_rental_id_seq OWNER TO postgres;
	
	
2023-02-21 13:16:48.557 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.557 EET [655626] STATEMENT:  ALTER TABLE public.rental OWNER TO postgres;
	
	
2023-02-21 13:16:48.562 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.562 EET [655626] STATEMENT:  ALTER TABLE public.sales_by_film_category OWNER TO postgres;
	
	
2023-02-21 13:16:48.566 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.566 EET [655626] STATEMENT:  ALTER TABLE public.staff_staff_id_seq OWNER TO postgres;
	
	
2023-02-21 13:16:48.574 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.574 EET [655626] STATEMENT:  ALTER TABLE public.staff OWNER TO postgres;
	
	
2023-02-21 13:16:48.578 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.578 EET [655626] STATEMENT:  ALTER TABLE public.store_store_id_seq OWNER TO postgres;
	
	
2023-02-21 13:16:48.583 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.583 EET [655626] STATEMENT:  ALTER TABLE public.store OWNER TO postgres;
	
	
2023-02-21 13:16:48.588 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.588 EET [655626] STATEMENT:  ALTER TABLE public.sales_by_store OWNER TO postgres;
	
	
2023-02-21 13:16:48.593 EET [655626] ERROR:  role "postgres" does not exist
2023-02-21 13:16:48.593 EET [655626] STATEMENT:  ALTER TABLE public.staff_list OWNER TO postgres;
	
	
2023-02-21 13:17:36.029 EET [655729] FATAL:  role "postgres" does not exist
2023-02-21 13:20:35.843 EET [656138] FATAL:  role "postgres" does not exist
2023-02-21 13:21:23.905 EET [656304] ERROR:  type "mpaa_rating" already exists
2023-02-21 13:21:23.905 EET [656304] STATEMENT:  CREATE TYPE public.mpaa_rating AS ENUM (
	    'G',
	    'PG',
	    'PG-13',
	    'R',
	    'NC-17'
	);
	
	
	
2023-02-21 13:21:23.912 EET [656304] ERROR:  type "year" already exists
2023-02-21 13:21:23.912 EET [656304] STATEMENT:  CREATE DOMAIN public.year AS integer
		CONSTRAINT year_check CHECK (((VALUE >= 1901) AND (VALUE <= 2155)));
	
	
	
2023-02-21 13:21:23.919 EET [656304] ERROR:  function "_group_concat" already exists with same argument types
2023-02-21 13:21:23.919 EET [656304] STATEMENT:  CREATE FUNCTION public._group_concat(text, text) RETURNS text
	    LANGUAGE sql IMMUTABLE
	    AS $_$
	SELECT CASE
	  WHEN $2 IS NULL THEN $1
	  WHEN $1 IS NULL THEN $2
	  ELSE $1 || ', ' || $2
	END
	$_$;
	
	
	
2023-02-21 13:21:23.925 EET [656304] ERROR:  function "film_in_stock" already exists with same argument types
2023-02-21 13:21:23.925 EET [656304] STATEMENT:  CREATE FUNCTION public.film_in_stock(p_film_id integer, p_store_id integer, OUT p_film_count integer) RETURNS SETOF integer
	    LANGUAGE sql
	    AS $_$
	     SELECT inventory_id
	     FROM inventory
	     WHERE film_id = $1
	     AND store_id = $2
	     AND inventory_in_stock(inventory_id);
	$_$;
	
	
	
2023-02-21 13:21:23.929 EET [656304] ERROR:  function "film_not_in_stock" already exists with same argument types
2023-02-21 13:21:23.929 EET [656304] STATEMENT:  CREATE FUNCTION public.film_not_in_stock(p_film_id integer, p_store_id integer, OUT p_film_count integer) RETURNS SETOF integer
	    LANGUAGE sql
	    AS $_$
	    SELECT inventory_id
	    FROM inventory
	    WHERE film_id = $1
	    AND store_id = $2
	    AND NOT inventory_in_stock(inventory_id);
	$_$;
	
	
	
2023-02-21 13:21:23.936 EET [656304] ERROR:  function "get_customer_balance" already exists with same argument types
2023-02-21 13:21:23.936 EET [656304] STATEMENT:  CREATE FUNCTION public.get_customer_balance(p_customer_id integer, p_effective_date timestamp without time zone) RETURNS numeric
	    LANGUAGE plpgsql
	    AS $$
	       --#OK, WE NEED TO CALCULATE THE CURRENT BALANCE GIVEN A CUSTOMER_ID AND A DATE
	       --#THAT WE WANT THE BALANCE TO BE EFFECTIVE FOR. THE BALANCE IS:
	       --#   1) RENTAL FEES FOR ALL PREVIOUS RENTALS
	       --#   2) ONE DOLLAR FOR EVERY DAY THE PREVIOUS RENTALS ARE OVERDUE
	       --#   3) IF A FILM IS MORE THAN RENTAL_DURATION * 2 OVERDUE, CHARGE THE REPLACEMENT_COST
	       --#   4) SUBTRACT ALL PAYMENTS MADE BEFORE THE DATE SPECIFIED
	DECLARE
	    v_rentfees DECIMAL(5,2); --#FEES PAID TO RENT THE VIDEOS INITIALLY
	    v_overfees INTEGER;      --#LATE FEES FOR PRIOR RENTALS
	    v_payments DECIMAL(5,2); --#SUM OF PAYMENTS MADE PREVIOUSLY
	BEGIN
	    SELECT COALESCE(SUM(film.rental_rate),0) INTO v_rentfees
	    FROM film, inventory, rental
	    WHERE film.film_id = inventory.film_id
	      AND inventory.inventory_id = rental.inventory_id
	      AND rental.rental_date <= p_effective_date
	      AND rental.customer_id = p_customer_id;
	
	    SELECT COALESCE(SUM(IF((rental.return_date - rental.rental_date) > (film.rental_duration * '1 day'::interval),
	        ((rental.return_date - rental.rental_date) - (film.rental_duration * '1 day'::interval)),0)),0) INTO v_overfees
	    FROM rental, inventory, film
	    WHERE film.film_id = inventory.film_id
	      AND inventory.inventory_id = rental.inventory_id
	      AND rental.rental_date <= p_effective_date
	      AND rental.customer_id = p_customer_id;
	
	    SELECT COALESCE(SUM(payment.amount),0) INTO v_payments
	    FROM payment
	    WHERE payment.payment_date <= p_effective_date
	    AND payment.customer_id = p_customer_id;
	
	    RETURN v_rentfees + v_overfees - v_payments;
	END
	$$;
	
	
	
2023-02-21 13:21:23.940 EET [656304] ERROR:  function "inventory_held_by_customer" already exists with same argument types
2023-02-21 13:21:23.940 EET [656304] STATEMENT:  CREATE FUNCTION public.inventory_held_by_customer(p_inventory_id integer) RETURNS integer
	    LANGUAGE plpgsql
	    AS $$
	DECLARE
	    v_customer_id INTEGER;
	BEGIN
	
	  SELECT customer_id INTO v_customer_id
	  FROM rental
	  WHERE return_date IS NULL
	  AND inventory_id = p_inventory_id;
	
	  RETURN v_customer_id;
	END $$;
	
	
	
2023-02-21 13:21:23.944 EET [656304] ERROR:  function "inventory_in_stock" already exists with same argument types
2023-02-21 13:21:23.944 EET [656304] STATEMENT:  CREATE FUNCTION public.inventory_in_stock(p_inventory_id integer) RETURNS boolean
	    LANGUAGE plpgsql
	    AS $$
	DECLARE
	    v_rentals INTEGER;
	    v_out     INTEGER;
	BEGIN
	    -- AN ITEM IS IN-STOCK IF THERE ARE EITHER NO ROWS IN THE rental TABLE
	    -- FOR THE ITEM OR ALL ROWS HAVE return_date POPULATED
	
	    SELECT count(*) INTO v_rentals
	    FROM rental
	    WHERE inventory_id = p_inventory_id;
	
	    IF v_rentals = 0 THEN
	      RETURN TRUE;
	    END IF;
	
	    SELECT COUNT(rental_id) INTO v_out
	    FROM inventory LEFT JOIN rental USING(inventory_id)
	    WHERE inventory.inventory_id = p_inventory_id
	    AND rental.return_date IS NULL;
	
	    IF v_out > 0 THEN
	      RETURN FALSE;
	    ELSE
	      RETURN TRUE;
	    END IF;
	END $$;
	
	
	
2023-02-21 13:21:23.948 EET [656304] ERROR:  function "last_day" already exists with same argument types
2023-02-21 13:21:23.948 EET [656304] STATEMENT:  CREATE FUNCTION public.last_day(timestamp without time zone) RETURNS date
	    LANGUAGE sql IMMUTABLE STRICT
	    AS $_$
	  SELECT CASE
	    WHEN EXTRACT(MONTH FROM $1) = 12 THEN
	      (((EXTRACT(YEAR FROM $1) + 1) operator(pg_catalog.||) '-01-01')::date - INTERVAL '1 day')::date
	    ELSE
	      ((EXTRACT(YEAR FROM $1) operator(pg_catalog.||) '-' operator(pg_catalog.||) (EXTRACT(MONTH FROM $1) + 1) operator(pg_catalog.||) '-01')::date - INTERVAL '1 day')::date
	    END
	$_$;
	
	
	
2023-02-21 13:21:23.952 EET [656304] ERROR:  function "last_updated" already exists with same argument types
2023-02-21 13:21:23.952 EET [656304] STATEMENT:  CREATE FUNCTION public.last_updated() RETURNS trigger
	    LANGUAGE plpgsql
	    AS $$
	BEGIN
	    NEW.last_update = CURRENT_TIMESTAMP;
	    RETURN NEW;
	END $$;
	
	
	
2023-02-21 13:21:23.956 EET [656304] ERROR:  relation "customer_customer_id_seq" already exists
2023-02-21 13:21:23.956 EET [656304] STATEMENT:  CREATE SEQUENCE public.customer_customer_id_seq
	    START WITH 1
	    INCREMENT BY 1
	    NO MINVALUE
	    NO MAXVALUE
	    CACHE 1;
	
	
	
2023-02-21 13:21:23.960 EET [656304] ERROR:  relation "customer" already exists
2023-02-21 13:21:23.960 EET [656304] STATEMENT:  CREATE TABLE public.customer (
	    customer_id integer DEFAULT nextval('public.customer_customer_id_seq'::regclass) NOT NULL,
	    store_id smallint NOT NULL,
	    first_name character varying(45) NOT NULL,
	    last_name character varying(45) NOT NULL,
	    email character varying(50),
	    address_id smallint NOT NULL,
	    activebool boolean DEFAULT true NOT NULL,
	    create_date date DEFAULT ('now'::text)::date NOT NULL,
	    last_update timestamp without time zone DEFAULT now(),
	    active integer
	);
	
	
	
2023-02-21 13:21:23.964 EET [656304] ERROR:  function "rewards_report" already exists with same argument types
2023-02-21 13:21:23.964 EET [656304] STATEMENT:  CREATE FUNCTION public.rewards_report(min_monthly_purchases integer, min_dollar_amount_purchased numeric) RETURNS SETOF public.customer
	    LANGUAGE plpgsql SECURITY DEFINER
	    AS $_$
	DECLARE
	    last_month_start DATE;
	    last_month_end DATE;
	rr RECORD;
	tmpSQL TEXT;
	BEGIN
	
	    /* Some sanity checks... */
	    IF min_monthly_purchases = 0 THEN
	        RAISE EXCEPTION 'Minimum monthly purchases parameter must be > 0';
	    END IF;
	    IF min_dollar_amount_purchased = 0.00 THEN
	        RAISE EXCEPTION 'Minimum monthly dollar amount purchased parameter must be > $0.00';
	    END IF;
	
	    last_month_start := CURRENT_DATE - '3 month'::interval;
	    last_month_start := to_date((extract(YEAR FROM last_month_start) || '-' || extract(MONTH FROM last_month_start) || '-01'),'YYYY-MM-DD');
	    last_month_end := LAST_DAY(last_month_start);
	
	    /*
	    Create a temporary storage area for Customer IDs.
	    */
	    CREATE TEMPORARY TABLE tmpCustomer (customer_id INTEGER NOT NULL PRIMARY KEY);
	
	    /*
	    Find all customers meeting the monthly purchase requirements
	    */
	
	    tmpSQL := 'INSERT INTO tmpCustomer (customer_id)
	        SELECT p.customer_id
	        FROM payment AS p
	        WHERE DATE(p.payment_date) BETWEEN '||quote_literal(last_month_start) ||' AND '|| quote_literal(last_month_end) || '
	        GROUP BY customer_id
	        HAVING SUM(p.amount) > '|| min_dollar_amount_purchased || '
	        AND COUNT(customer_id) > ' ||min_monthly_purchases ;
	
	    EXECUTE tmpSQL;
	
	    /*
	    Output ALL customer information of matching rewardees.
	    Customize output as needed.
	    */
	    FOR rr IN EXECUTE 'SELECT c.* FROM tmpCustomer AS t INNER JOIN customer AS c ON t.customer_id = c.customer_id' LOOP
	        RETURN NEXT rr;
	    END LOOP;
	
	    /* Clean up */
	    tmpSQL := 'DROP TABLE tmpCustomer';
	    EXECUTE tmpSQL;
	
	RETURN;
	END
	$_$;
	
	
	
2023-02-21 13:21:23.968 EET [656304] ERROR:  function "group_concat" already exists with same argument types
2023-02-21 13:21:23.968 EET [656304] STATEMENT:  CREATE AGGREGATE public.group_concat(text) (
	    SFUNC = public._group_concat,
	    STYPE = text
	);
	
	
	
2023-02-21 13:21:23.972 EET [656304] ERROR:  relation "actor_actor_id_seq" already exists
2023-02-21 13:21:23.972 EET [656304] STATEMENT:  CREATE SEQUENCE public.actor_actor_id_seq
	    START WITH 1
	    INCREMENT BY 1
	    NO MINVALUE
	    NO MAXVALUE
	    CACHE 1;
	
	
	
2023-02-21 13:21:23.976 EET [656304] ERROR:  relation "actor" already exists
2023-02-21 13:21:23.976 EET [656304] STATEMENT:  CREATE TABLE public.actor (
	    actor_id integer DEFAULT nextval('public.actor_actor_id_seq'::regclass) NOT NULL,
	    first_name character varying(45) NOT NULL,
	    last_name character varying(45) NOT NULL,
	    last_update timestamp without time zone DEFAULT now() NOT NULL
	);
	
	
	
2023-02-21 13:21:23.980 EET [656304] ERROR:  relation "category_category_id_seq" already exists
2023-02-21 13:21:23.980 EET [656304] STATEMENT:  CREATE SEQUENCE public.category_category_id_seq
	    START WITH 1
	    INCREMENT BY 1
	    NO MINVALUE
	    NO MAXVALUE
	    CACHE 1;
	
	
	
2023-02-21 13:21:23.984 EET [656304] ERROR:  relation "category" already exists
2023-02-21 13:21:23.984 EET [656304] STATEMENT:  CREATE TABLE public.category (
	    category_id integer DEFAULT nextval('public.category_category_id_seq'::regclass) NOT NULL,
	    name character varying(25) NOT NULL,
	    last_update timestamp without time zone DEFAULT now() NOT NULL
	);
	
	
	
2023-02-21 13:21:23.988 EET [656304] ERROR:  relation "film_film_id_seq" already exists
2023-02-21 13:21:23.988 EET [656304] STATEMENT:  CREATE SEQUENCE public.film_film_id_seq
	    START WITH 1
	    INCREMENT BY 1
	    NO MINVALUE
	    NO MAXVALUE
	    CACHE 1;
	
	
	
2023-02-21 13:21:23.992 EET [656304] ERROR:  relation "film" already exists
2023-02-21 13:21:23.992 EET [656304] STATEMENT:  CREATE TABLE public.film (
	    film_id integer DEFAULT nextval('public.film_film_id_seq'::regclass) NOT NULL,
	    title character varying(255) NOT NULL,
	    description text,
	    release_year public.year,
	    language_id smallint NOT NULL,
	    rental_duration smallint DEFAULT 3 NOT NULL,
	    rental_rate numeric(4,2) DEFAULT 4.99 NOT NULL,
	    length smallint,
	    replacement_cost numeric(5,2) DEFAULT 19.99 NOT NULL,
	    rating public.mpaa_rating DEFAULT 'G'::public.mpaa_rating,
	    last_update timestamp without time zone DEFAULT now() NOT NULL,
	    special_features text[],
	    fulltext tsvector NOT NULL
	);
	
	
	
2023-02-21 13:21:23.996 EET [656304] ERROR:  relation "film_actor" already exists
2023-02-21 13:21:23.996 EET [656304] STATEMENT:  CREATE TABLE public.film_actor (
	    actor_id smallint NOT NULL,
	    film_id smallint NOT NULL,
	    last_update timestamp without time zone DEFAULT now() NOT NULL
	);
	
	
	
2023-02-21 13:21:24.000 EET [656304] ERROR:  relation "film_category" already exists
2023-02-21 13:21:24.000 EET [656304] STATEMENT:  CREATE TABLE public.film_category (
	    film_id smallint NOT NULL,
	    category_id smallint NOT NULL,
	    last_update timestamp without time zone DEFAULT now() NOT NULL
	);
	
	
	
2023-02-21 13:21:24.004 EET [656304] ERROR:  relation "actor_info" already exists
2023-02-21 13:21:24.004 EET [656304] STATEMENT:  CREATE VIEW public.actor_info AS
	 SELECT a.actor_id,
	    a.first_name,
	    a.last_name,
	    public.group_concat(DISTINCT (((c.name)::text || ': '::text) || ( SELECT public.group_concat((f.title)::text) AS group_concat
	           FROM ((public.film f
	             JOIN public.film_category fc_1 ON ((f.film_id = fc_1.film_id)))
	             JOIN public.film_actor fa_1 ON ((f.film_id = fa_1.film_id)))
	          WHERE ((fc_1.category_id = c.category_id) AND (fa_1.actor_id = a.actor_id))
	          GROUP BY fa_1.actor_id))) AS film_info
	   FROM (((public.actor a
	     LEFT JOIN public.film_actor fa ON ((a.actor_id = fa.actor_id)))
	     LEFT JOIN public.film_category fc ON ((fa.film_id = fc.film_id)))
	     LEFT JOIN public.category c ON ((fc.category_id = c.category_id)))
	  GROUP BY a.actor_id, a.first_name, a.last_name;
	
	
	
2023-02-21 13:21:24.008 EET [656304] ERROR:  relation "address_address_id_seq" already exists
2023-02-21 13:21:24.008 EET [656304] STATEMENT:  CREATE SEQUENCE public.address_address_id_seq
	    START WITH 1
	    INCREMENT BY 1
	    NO MINVALUE
	    NO MAXVALUE
	    CACHE 1;
	
	
	
2023-02-21 13:21:24.012 EET [656304] ERROR:  relation "address" already exists
2023-02-21 13:21:24.012 EET [656304] STATEMENT:  CREATE TABLE public.address (
	    address_id integer DEFAULT nextval('public.address_address_id_seq'::regclass) NOT NULL,
	    address character varying(50) NOT NULL,
	    address2 character varying(50),
	    district character varying(20) NOT NULL,
	    city_id smallint NOT NULL,
	    postal_code character varying(10),
	    phone character varying(20) NOT NULL,
	    last_update timestamp without time zone DEFAULT now() NOT NULL
	);
	
	
	
2023-02-21 13:21:24.019 EET [656304] ERROR:  relation "city_city_id_seq" already exists
2023-02-21 13:21:24.019 EET [656304] STATEMENT:  CREATE SEQUENCE public.city_city_id_seq
	    START WITH 1
	    INCREMENT BY 1
	    NO MINVALUE
	    NO MAXVALUE
	    CACHE 1;
	
	
	
2023-02-21 13:21:24.023 EET [656304] ERROR:  relation "city" already exists
2023-02-21 13:21:24.023 EET [656304] STATEMENT:  CREATE TABLE public.city (
	    city_id integer DEFAULT nextval('public.city_city_id_seq'::regclass) NOT NULL,
	    city character varying(50) NOT NULL,
	    country_id smallint NOT NULL,
	    last_update timestamp without time zone DEFAULT now() NOT NULL
	);
	
	
	
2023-02-21 13:21:24.027 EET [656304] ERROR:  relation "country_country_id_seq" already exists
2023-02-21 13:21:24.027 EET [656304] STATEMENT:  CREATE SEQUENCE public.country_country_id_seq
	    START WITH 1
	    INCREMENT BY 1
	    NO MINVALUE
	    NO MAXVALUE
	    CACHE 1;
	
	
	
2023-02-21 13:21:24.030 EET [656304] ERROR:  relation "country" already exists
2023-02-21 13:21:24.030 EET [656304] STATEMENT:  CREATE TABLE public.country (
	    country_id integer DEFAULT nextval('public.country_country_id_seq'::regclass) NOT NULL,
	    country character varying(50) NOT NULL,
	    last_update timestamp without time zone DEFAULT now() NOT NULL
	);
	
	
	
2023-02-21 13:21:24.034 EET [656304] ERROR:  relation "customer_list" already exists
2023-02-21 13:21:24.034 EET [656304] STATEMENT:  CREATE VIEW public.customer_list AS
	 SELECT cu.customer_id AS id,
	    (((cu.first_name)::text || ' '::text) || (cu.last_name)::text) AS name,
	    a.address,
	    a.postal_code AS "zip code",
	    a.phone,
	    city.city,
	    country.country,
	        CASE
	            WHEN cu.activebool THEN 'active'::text
	            ELSE ''::text
	        END AS notes,
	    cu.store_id AS sid
	   FROM (((public.customer cu
	     JOIN public.address a ON ((cu.address_id = a.address_id)))
	     JOIN public.city ON ((a.city_id = city.city_id)))
	     JOIN public.country ON ((city.country_id = country.country_id)));
	
	
	
2023-02-21 13:21:24.039 EET [656304] ERROR:  relation "film_list" already exists
2023-02-21 13:21:24.039 EET [656304] STATEMENT:  CREATE VIEW public.film_list AS
	 SELECT film.film_id AS fid,
	    film.title,
	    film.description,
	    category.name AS category,
	    film.rental_rate AS price,
	    film.length,
	    film.rating,
	    public.group_concat((((actor.first_name)::text || ' '::text) || (actor.last_name)::text)) AS actors
	   FROM ((((public.category
	     LEFT JOIN public.film_category ON ((category.category_id = film_category.category_id)))
	     LEFT JOIN public.film ON ((film_category.film_id = film.film_id)))
	     JOIN public.film_actor ON ((film.film_id = film_actor.film_id)))
	     JOIN public.actor ON ((film_actor.actor_id = actor.actor_id)))
	  GROUP BY film.film_id, film.title, film.description, category.name, film.rental_rate, film.length, film.rating;
	
	
	
2023-02-21 13:21:24.043 EET [656304] ERROR:  relation "inventory_inventory_id_seq" already exists
2023-02-21 13:21:24.043 EET [656304] STATEMENT:  CREATE SEQUENCE public.inventory_inventory_id_seq
	    START WITH 1
	    INCREMENT BY 1
	    NO MINVALUE
	    NO MAXVALUE
	    CACHE 1;
	
	
	
2023-02-21 13:21:24.047 EET [656304] ERROR:  relation "inventory" already exists
2023-02-21 13:21:24.047 EET [656304] STATEMENT:  CREATE TABLE public.inventory (
	    inventory_id integer DEFAULT nextval('public.inventory_inventory_id_seq'::regclass) NOT NULL,
	    film_id smallint NOT NULL,
	    store_id smallint NOT NULL,
	    last_update timestamp without time zone DEFAULT now() NOT NULL
	);
	
	
	
2023-02-21 13:21:24.052 EET [656304] ERROR:  relation "language_language_id_seq" already exists
2023-02-21 13:21:24.052 EET [656304] STATEMENT:  CREATE SEQUENCE public.language_language_id_seq
	    START WITH 1
	    INCREMENT BY 1
	    NO MINVALUE
	    NO MAXVALUE
	    CACHE 1;
	
	
	
2023-02-21 13:21:24.056 EET [656304] ERROR:  relation "language" already exists
2023-02-21 13:21:24.056 EET [656304] STATEMENT:  CREATE TABLE public.language (
	    language_id integer DEFAULT nextval('public.language_language_id_seq'::regclass) NOT NULL,
	    name character(20) NOT NULL,
	    last_update timestamp without time zone DEFAULT now() NOT NULL
	);
	
	
	
2023-02-21 13:21:24.060 EET [656304] ERROR:  relation "nicer_but_slower_film_list" already exists
2023-02-21 13:21:24.060 EET [656304] STATEMENT:  CREATE VIEW public.nicer_but_slower_film_list AS
	 SELECT film.film_id AS fid,
	    film.title,
	    film.description,
	    category.name AS category,
	    film.rental_rate AS price,
	    film.length,
	    film.rating,
	    public.group_concat((((upper("substring"((actor.first_name)::text, 1, 1)) || lower("substring"((actor.first_name)::text, 2))) || upper("substring"((actor.last_name)::text, 1, 1))) || lower("substring"((actor.last_name)::text, 2)))) AS actors
	   FROM ((((public.category
	     LEFT JOIN public.film_category ON ((category.category_id = film_category.category_id)))
	     LEFT JOIN public.film ON ((film_category.film_id = film.film_id)))
	     JOIN public.film_actor ON ((film.film_id = film_actor.film_id)))
	     JOIN public.actor ON ((film_actor.actor_id = actor.actor_id)))
	  GROUP BY film.film_id, film.title, film.description, category.name, film.rental_rate, film.length, film.rating;
	
	
	
2023-02-21 13:21:24.064 EET [656304] ERROR:  relation "payment_payment_id_seq" already exists
2023-02-21 13:21:24.064 EET [656304] STATEMENT:  CREATE SEQUENCE public.payment_payment_id_seq
	    START WITH 1
	    INCREMENT BY 1
	    NO MINVALUE
	    NO MAXVALUE
	    CACHE 1;
	
	
	
2023-02-21 13:21:24.067 EET [656304] ERROR:  relation "payment" already exists
2023-02-21 13:21:24.067 EET [656304] STATEMENT:  CREATE TABLE public.payment (
	    payment_id integer DEFAULT nextval('public.payment_payment_id_seq'::regclass) NOT NULL,
	    customer_id smallint NOT NULL,
	    staff_id smallint NOT NULL,
	    rental_id integer NOT NULL,
	    amount numeric(5,2) NOT NULL,
	    payment_date timestamp without time zone NOT NULL
	);
	
	
	
2023-02-21 13:21:24.071 EET [656304] ERROR:  relation "rental_rental_id_seq" already exists
2023-02-21 13:21:24.071 EET [656304] STATEMENT:  CREATE SEQUENCE public.rental_rental_id_seq
	    START WITH 1
	    INCREMENT BY 1
	    NO MINVALUE
	    NO MAXVALUE
	    CACHE 1;
	
	
	
2023-02-21 13:21:24.075 EET [656304] ERROR:  relation "rental" already exists
2023-02-21 13:21:24.075 EET [656304] STATEMENT:  CREATE TABLE public.rental (
	    rental_id integer DEFAULT nextval('public.rental_rental_id_seq'::regclass) NOT NULL,
	    rental_date timestamp without time zone NOT NULL,
	    inventory_id integer NOT NULL,
	    customer_id smallint NOT NULL,
	    return_date timestamp without time zone,
	    staff_id smallint NOT NULL,
	    last_update timestamp without time zone DEFAULT now() NOT NULL
	);
	
	
	
2023-02-21 13:21:24.079 EET [656304] ERROR:  relation "sales_by_film_category" already exists
2023-02-21 13:21:24.079 EET [656304] STATEMENT:  CREATE VIEW public.sales_by_film_category AS
	 SELECT c.name AS category,
	    sum(p.amount) AS total_sales
	   FROM (((((public.payment p
	     JOIN public.rental r ON ((p.rental_id = r.rental_id)))
	     JOIN public.inventory i ON ((r.inventory_id = i.inventory_id)))
	     JOIN public.film f ON ((i.film_id = f.film_id)))
	     JOIN public.film_category fc ON ((f.film_id = fc.film_id)))
	     JOIN public.category c ON ((fc.category_id = c.category_id)))
	  GROUP BY c.name
	  ORDER BY (sum(p.amount)) DESC;
	
	
	
2023-02-21 13:21:24.083 EET [656304] ERROR:  relation "staff_staff_id_seq" already exists
2023-02-21 13:21:24.083 EET [656304] STATEMENT:  CREATE SEQUENCE public.staff_staff_id_seq
	    START WITH 1
	    INCREMENT BY 1
	    NO MINVALUE
	    NO MAXVALUE
	    CACHE 1;
	
	
	
2023-02-21 13:21:24.087 EET [656304] ERROR:  relation "staff" already exists
2023-02-21 13:21:24.087 EET [656304] STATEMENT:  CREATE TABLE public.staff (
	    staff_id integer DEFAULT nextval('public.staff_staff_id_seq'::regclass) NOT NULL,
	    first_name character varying(45) NOT NULL,
	    last_name character varying(45) NOT NULL,
	    address_id smallint NOT NULL,
	    email character varying(50),
	    store_id smallint NOT NULL,
	    active boolean DEFAULT true NOT NULL,
	    username character varying(16) NOT NULL,
	    password character varying(40),
	    last_update timestamp without time zone DEFAULT now() NOT NULL,
	    picture bytea
	);
	
	
	
2023-02-21 13:21:24.092 EET [656304] ERROR:  relation "store_store_id_seq" already exists
2023-02-21 13:21:24.092 EET [656304] STATEMENT:  CREATE SEQUENCE public.store_store_id_seq
	    START WITH 1
	    INCREMENT BY 1
	    NO MINVALUE
	    NO MAXVALUE
	    CACHE 1;
	
	
	
2023-02-21 13:21:24.095 EET [656304] ERROR:  relation "store" already exists
2023-02-21 13:21:24.095 EET [656304] STATEMENT:  CREATE TABLE public.store (
	    store_id integer DEFAULT nextval('public.store_store_id_seq'::regclass) NOT NULL,
	    manager_staff_id smallint NOT NULL,
	    address_id smallint NOT NULL,
	    last_update timestamp without time zone DEFAULT now() NOT NULL
	);
	
	
	
2023-02-21 13:21:24.099 EET [656304] ERROR:  relation "sales_by_store" already exists
2023-02-21 13:21:24.099 EET [656304] STATEMENT:  CREATE VIEW public.sales_by_store AS
	 SELECT (((c.city)::text || ','::text) || (cy.country)::text) AS store,
	    (((m.first_name)::text || ' '::text) || (m.last_name)::text) AS manager,
	    sum(p.amount) AS total_sales
	   FROM (((((((public.payment p
	     JOIN public.rental r ON ((p.rental_id = r.rental_id)))
	     JOIN public.inventory i ON ((r.inventory_id = i.inventory_id)))
	     JOIN public.store s ON ((i.store_id = s.store_id)))
	     JOIN public.address a ON ((s.address_id = a.address_id)))
	     JOIN public.city c ON ((a.city_id = c.city_id)))
	     JOIN public.country cy ON ((c.country_id = cy.country_id)))
	     JOIN public.staff m ON ((s.manager_staff_id = m.staff_id)))
	  GROUP BY cy.country, c.city, s.store_id, m.first_name, m.last_name
	  ORDER BY cy.country, c.city;
	
	
	
2023-02-21 13:21:24.104 EET [656304] ERROR:  relation "staff_list" already exists
2023-02-21 13:21:24.104 EET [656304] STATEMENT:  CREATE VIEW public.staff_list AS
	 SELECT s.staff_id AS id,
	    (((s.first_name)::text || ' '::text) || (s.last_name)::text) AS name,
	    a.address,
	    a.postal_code AS "zip code",
	    a.phone,
	    city.city,
	    country.country,
	    s.store_id AS sid
	   FROM (((public.staff s
	     JOIN public.address a ON ((s.address_id = a.address_id)))
	     JOIN public.city ON ((a.city_id = city.city_id)))
	     JOIN public.country ON ((city.country_id = country.country_id)));
	
	
	
2023-02-21 13:21:24.109 EET [656304] ERROR:  duplicate key value violates unique constraint "actor_pkey"
2023-02-21 13:21:24.109 EET [656304] DETAIL:  Key (actor_id)=(1) already exists.
2023-02-21 13:21:24.109 EET [656304] CONTEXT:  COPY actor, line 1
2023-02-21 13:21:24.109 EET [656304] STATEMENT:  COPY public.actor (actor_id, first_name, last_name, last_update) FROM stdin;
	
2023-02-21 13:21:24.111 EET [656304] ERROR:  duplicate key value violates unique constraint "address_pkey"
2023-02-21 13:21:24.111 EET [656304] DETAIL:  Key (address_id)=(1) already exists.
2023-02-21 13:21:24.111 EET [656304] CONTEXT:  COPY address, line 1
2023-02-21 13:21:24.111 EET [656304] STATEMENT:  COPY public.address (address_id, address, address2, district, city_id, postal_code, phone, last_update) FROM stdin;
	
2023-02-21 13:21:24.111 EET [656304] ERROR:  duplicate key value violates unique constraint "category_pkey"
2023-02-21 13:21:24.111 EET [656304] DETAIL:  Key (category_id)=(1) already exists.
2023-02-21 13:21:24.111 EET [656304] CONTEXT:  COPY category, line 1
2023-02-21 13:21:24.111 EET [656304] STATEMENT:  COPY public.category (category_id, name, last_update) FROM stdin;
	
2023-02-21 13:21:24.112 EET [656304] ERROR:  duplicate key value violates unique constraint "city_pkey"
2023-02-21 13:21:24.112 EET [656304] DETAIL:  Key (city_id)=(1) already exists.
2023-02-21 13:21:24.112 EET [656304] CONTEXT:  COPY city, line 1
2023-02-21 13:21:24.112 EET [656304] STATEMENT:  COPY public.city (city_id, city, country_id, last_update) FROM stdin;
	
2023-02-21 13:21:24.113 EET [656304] ERROR:  duplicate key value violates unique constraint "country_pkey"
2023-02-21 13:21:24.113 EET [656304] DETAIL:  Key (country_id)=(1) already exists.
2023-02-21 13:21:24.113 EET [656304] CONTEXT:  COPY country, line 1
2023-02-21 13:21:24.113 EET [656304] STATEMENT:  COPY public.country (country_id, country, last_update) FROM stdin;
	
2023-02-21 13:21:24.115 EET [656304] ERROR:  duplicate key value violates unique constraint "customer_pkey"
2023-02-21 13:21:24.115 EET [656304] DETAIL:  Key (customer_id)=(524) already exists.
2023-02-21 13:21:24.115 EET [656304] CONTEXT:  COPY customer, line 1
2023-02-21 13:21:24.115 EET [656304] STATEMENT:  COPY public.customer (customer_id, store_id, first_name, last_name, email, address_id, activebool, create_date, last_update, active) FROM stdin;
	
2023-02-21 13:21:24.117 EET [656304] ERROR:  duplicate key value violates unique constraint "film_pkey"
2023-02-21 13:21:24.117 EET [656304] DETAIL:  Key (film_id)=(133) already exists.
2023-02-21 13:21:24.117 EET [656304] CONTEXT:  COPY film, line 1: "133	Chamber Italian	A Fateful Reflection of a Moose And a Husband who must Overcome a Monkey in Nige..."
2023-02-21 13:21:24.117 EET [656304] STATEMENT:  COPY public.film (film_id, title, description, release_year, language_id, rental_duration, rental_rate, length, replacement_cost, rating, last_update, special_features, fulltext) FROM stdin;
	
2023-02-21 13:21:24.118 EET [656304] ERROR:  duplicate key value violates unique constraint "film_actor_pkey"
2023-02-21 13:21:24.118 EET [656304] DETAIL:  Key (actor_id, film_id)=(1, 1) already exists.
2023-02-21 13:21:24.118 EET [656304] CONTEXT:  COPY film_actor, line 1
2023-02-21 13:21:24.118 EET [656304] STATEMENT:  COPY public.film_actor (actor_id, film_id, last_update) FROM stdin;
	
2023-02-21 13:21:24.120 EET [656304] ERROR:  duplicate key value violates unique constraint "film_category_pkey"
2023-02-21 13:21:24.120 EET [656304] DETAIL:  Key (film_id, category_id)=(1, 6) already exists.
2023-02-21 13:21:24.120 EET [656304] CONTEXT:  COPY film_category, line 1
2023-02-21 13:21:24.120 EET [656304] STATEMENT:  COPY public.film_category (film_id, category_id, last_update) FROM stdin;
	
2023-02-21 13:21:24.122 EET [656304] ERROR:  duplicate key value violates unique constraint "inventory_pkey"
2023-02-21 13:21:24.122 EET [656304] DETAIL:  Key (inventory_id)=(1) already exists.
2023-02-21 13:21:24.122 EET [656304] CONTEXT:  COPY inventory, line 1
2023-02-21 13:21:24.122 EET [656304] STATEMENT:  COPY public.inventory (inventory_id, film_id, store_id, last_update) FROM stdin;
	
2023-02-21 13:21:24.123 EET [656304] ERROR:  duplicate key value violates unique constraint "language_pkey"
2023-02-21 13:21:24.123 EET [656304] DETAIL:  Key (language_id)=(1) already exists.
2023-02-21 13:21:24.123 EET [656304] CONTEXT:  COPY language, line 1
2023-02-21 13:21:24.123 EET [656304] STATEMENT:  COPY public.language (language_id, name, last_update) FROM stdin;
	
2023-02-21 13:21:24.126 EET [656304] ERROR:  duplicate key value violates unique constraint "payment_pkey"
2023-02-21 13:21:24.126 EET [656304] DETAIL:  Key (payment_id)=(17503) already exists.
2023-02-21 13:21:24.126 EET [656304] CONTEXT:  COPY payment, line 1
2023-02-21 13:21:24.126 EET [656304] STATEMENT:  COPY public.payment (payment_id, customer_id, staff_id, rental_id, amount, payment_date) FROM stdin;
	
2023-02-21 13:21:24.129 EET [656304] ERROR:  duplicate key value violates unique constraint "rental_pkey"
2023-02-21 13:21:24.129 EET [656304] DETAIL:  Key (rental_id)=(2) already exists.
2023-02-21 13:21:24.129 EET [656304] CONTEXT:  COPY rental, line 1
2023-02-21 13:21:24.129 EET [656304] STATEMENT:  COPY public.rental (rental_id, rental_date, inventory_id, customer_id, return_date, staff_id, last_update) FROM stdin;
	
2023-02-21 13:21:24.131 EET [656304] ERROR:  duplicate key value violates unique constraint "staff_pkey"
2023-02-21 13:21:24.131 EET [656304] DETAIL:  Key (staff_id)=(1) already exists.
2023-02-21 13:21:24.131 EET [656304] CONTEXT:  COPY staff, line 1
2023-02-21 13:21:24.131 EET [656304] STATEMENT:  COPY public.staff (staff_id, first_name, last_name, address_id, email, store_id, active, username, password, last_update, picture) FROM stdin;
	
2023-02-21 13:21:24.131 EET [656304] ERROR:  duplicate key value violates unique constraint "store_pkey"
2023-02-21 13:21:24.131 EET [656304] DETAIL:  Key (store_id)=(1) already exists.
2023-02-21 13:21:24.131 EET [656304] CONTEXT:  COPY store, line 1
2023-02-21 13:21:24.131 EET [656304] STATEMENT:  COPY public.store (store_id, manager_staff_id, address_id, last_update) FROM stdin;
	
2023-02-21 13:21:24.183 EET [656304] ERROR:  multiple primary keys for table "actor" are not allowed
2023-02-21 13:21:24.183 EET [656304] STATEMENT:  ALTER TABLE ONLY public.actor
	    ADD CONSTRAINT actor_pkey PRIMARY KEY (actor_id);
	
	
	
2023-02-21 13:21:24.183 EET [656304] ERROR:  multiple primary keys for table "address" are not allowed
2023-02-21 13:21:24.183 EET [656304] STATEMENT:  ALTER TABLE ONLY public.address
	    ADD CONSTRAINT address_pkey PRIMARY KEY (address_id);
	
	
	
2023-02-21 13:21:24.183 EET [656304] ERROR:  multiple primary keys for table "category" are not allowed
2023-02-21 13:21:24.183 EET [656304] STATEMENT:  ALTER TABLE ONLY public.category
	    ADD CONSTRAINT category_pkey PRIMARY KEY (category_id);
	
	
	
2023-02-21 13:21:24.183 EET [656304] ERROR:  multiple primary keys for table "city" are not allowed
2023-02-21 13:21:24.183 EET [656304] STATEMENT:  ALTER TABLE ONLY public.city
	    ADD CONSTRAINT city_pkey PRIMARY KEY (city_id);
	
	
	
2023-02-21 13:21:24.183 EET [656304] ERROR:  multiple primary keys for table "country" are not allowed
2023-02-21 13:21:24.183 EET [656304] STATEMENT:  ALTER TABLE ONLY public.country
	    ADD CONSTRAINT country_pkey PRIMARY KEY (country_id);
	
	
	
2023-02-21 13:21:24.184 EET [656304] ERROR:  multiple primary keys for table "customer" are not allowed
2023-02-21 13:21:24.184 EET [656304] STATEMENT:  ALTER TABLE ONLY public.customer
	    ADD CONSTRAINT customer_pkey PRIMARY KEY (customer_id);
	
	
	
2023-02-21 13:21:24.184 EET [656304] ERROR:  multiple primary keys for table "film_actor" are not allowed
2023-02-21 13:21:24.184 EET [656304] STATEMENT:  ALTER TABLE ONLY public.film_actor
	    ADD CONSTRAINT film_actor_pkey PRIMARY KEY (actor_id, film_id);
	
	
	
2023-02-21 13:21:24.184 EET [656304] ERROR:  multiple primary keys for table "film_category" are not allowed
2023-02-21 13:21:24.184 EET [656304] STATEMENT:  ALTER TABLE ONLY public.film_category
	    ADD CONSTRAINT film_category_pkey PRIMARY KEY (film_id, category_id);
	
	
	
2023-02-21 13:21:24.184 EET [656304] ERROR:  multiple primary keys for table "film" are not allowed
2023-02-21 13:21:24.184 EET [656304] STATEMENT:  ALTER TABLE ONLY public.film
	    ADD CONSTRAINT film_pkey PRIMARY KEY (film_id);
	
	
	
2023-02-21 13:21:24.184 EET [656304] ERROR:  multiple primary keys for table "inventory" are not allowed
2023-02-21 13:21:24.184 EET [656304] STATEMENT:  ALTER TABLE ONLY public.inventory
	    ADD CONSTRAINT inventory_pkey PRIMARY KEY (inventory_id);
	
	
	
2023-02-21 13:21:24.184 EET [656304] ERROR:  multiple primary keys for table "language" are not allowed
2023-02-21 13:21:24.184 EET [656304] STATEMENT:  ALTER TABLE ONLY public.language
	    ADD CONSTRAINT language_pkey PRIMARY KEY (language_id);
	
	
	
2023-02-21 13:21:24.184 EET [656304] ERROR:  multiple primary keys for table "payment" are not allowed
2023-02-21 13:21:24.184 EET [656304] STATEMENT:  ALTER TABLE ONLY public.payment
	    ADD CONSTRAINT payment_pkey PRIMARY KEY (payment_id);
	
	
	
2023-02-21 13:21:24.185 EET [656304] ERROR:  multiple primary keys for table "rental" are not allowed
2023-02-21 13:21:24.185 EET [656304] STATEMENT:  ALTER TABLE ONLY public.rental
	    ADD CONSTRAINT rental_pkey PRIMARY KEY (rental_id);
	
	
	
2023-02-21 13:21:24.185 EET [656304] ERROR:  multiple primary keys for table "staff" are not allowed
2023-02-21 13:21:24.185 EET [656304] STATEMENT:  ALTER TABLE ONLY public.staff
	    ADD CONSTRAINT staff_pkey PRIMARY KEY (staff_id);
	
	
	
2023-02-21 13:21:24.185 EET [656304] ERROR:  multiple primary keys for table "store" are not allowed
2023-02-21 13:21:24.185 EET [656304] STATEMENT:  ALTER TABLE ONLY public.store
	    ADD CONSTRAINT store_pkey PRIMARY KEY (store_id);
	
	
	
2023-02-21 13:21:24.185 EET [656304] ERROR:  relation "film_fulltext_idx" already exists
2023-02-21 13:21:24.185 EET [656304] STATEMENT:  CREATE INDEX film_fulltext_idx ON public.film USING gist (fulltext);
	
	
	
2023-02-21 13:21:24.185 EET [656304] ERROR:  relation "idx_actor_last_name" already exists
2023-02-21 13:21:24.185 EET [656304] STATEMENT:  CREATE INDEX idx_actor_last_name ON public.actor USING btree (last_name);
	
	
	
2023-02-21 13:21:24.185 EET [656304] ERROR:  relation "idx_fk_address_id" already exists
2023-02-21 13:21:24.185 EET [656304] STATEMENT:  CREATE INDEX idx_fk_address_id ON public.customer USING btree (address_id);
	
	
	
2023-02-21 13:21:24.185 EET [656304] ERROR:  relation "idx_fk_city_id" already exists
2023-02-21 13:21:24.185 EET [656304] STATEMENT:  CREATE INDEX idx_fk_city_id ON public.address USING btree (city_id);
	
	
	
2023-02-21 13:21:24.186 EET [656304] ERROR:  relation "idx_fk_country_id" already exists
2023-02-21 13:21:24.186 EET [656304] STATEMENT:  CREATE INDEX idx_fk_country_id ON public.city USING btree (country_id);
	
	
	
2023-02-21 13:21:24.186 EET [656304] ERROR:  relation "idx_fk_customer_id" already exists
2023-02-21 13:21:24.186 EET [656304] STATEMENT:  CREATE INDEX idx_fk_customer_id ON public.payment USING btree (customer_id);
	
	
	
2023-02-21 13:21:24.186 EET [656304] ERROR:  relation "idx_fk_film_id" already exists
2023-02-21 13:21:24.186 EET [656304] STATEMENT:  CREATE INDEX idx_fk_film_id ON public.film_actor USING btree (film_id);
	
	
	
2023-02-21 13:21:24.186 EET [656304] ERROR:  relation "idx_fk_inventory_id" already exists
2023-02-21 13:21:24.186 EET [656304] STATEMENT:  CREATE INDEX idx_fk_inventory_id ON public.rental USING btree (inventory_id);
	
	
	
2023-02-21 13:21:24.186 EET [656304] ERROR:  relation "idx_fk_language_id" already exists
2023-02-21 13:21:24.186 EET [656304] STATEMENT:  CREATE INDEX idx_fk_language_id ON public.film USING btree (language_id);
	
	
	
2023-02-21 13:21:24.186 EET [656304] ERROR:  relation "idx_fk_rental_id" already exists
2023-02-21 13:21:24.186 EET [656304] STATEMENT:  CREATE INDEX idx_fk_rental_id ON public.payment USING btree (rental_id);
	
	
	
2023-02-21 13:21:24.186 EET [656304] ERROR:  relation "idx_fk_staff_id" already exists
2023-02-21 13:21:24.186 EET [656304] STATEMENT:  CREATE INDEX idx_fk_staff_id ON public.payment USING btree (staff_id);
	
	
	
2023-02-21 13:21:24.186 EET [656304] ERROR:  relation "idx_fk_store_id" already exists
2023-02-21 13:21:24.186 EET [656304] STATEMENT:  CREATE INDEX idx_fk_store_id ON public.customer USING btree (store_id);
	
	
	
2023-02-21 13:21:24.186 EET [656304] ERROR:  relation "idx_last_name" already exists
2023-02-21 13:21:24.186 EET [656304] STATEMENT:  CREATE INDEX idx_last_name ON public.customer USING btree (last_name);
	
	
	
2023-02-21 13:21:24.187 EET [656304] ERROR:  relation "idx_store_id_film_id" already exists
2023-02-21 13:21:24.187 EET [656304] STATEMENT:  CREATE INDEX idx_store_id_film_id ON public.inventory USING btree (store_id, film_id);
	
	
	
2023-02-21 13:21:24.187 EET [656304] ERROR:  relation "idx_title" already exists
2023-02-21 13:21:24.187 EET [656304] STATEMENT:  CREATE INDEX idx_title ON public.film USING btree (title);
	
	
	
2023-02-21 13:21:24.187 EET [656304] ERROR:  relation "idx_unq_manager_staff_id" already exists
2023-02-21 13:21:24.187 EET [656304] STATEMENT:  CREATE UNIQUE INDEX idx_unq_manager_staff_id ON public.store USING btree (manager_staff_id);
	
	
	
2023-02-21 13:21:24.187 EET [656304] ERROR:  relation "idx_unq_rental_rental_date_inventory_id_customer_id" already exists
2023-02-21 13:21:24.187 EET [656304] STATEMENT:  CREATE UNIQUE INDEX idx_unq_rental_rental_date_inventory_id_customer_id ON public.rental USING btree (rental_date, inventory_id, customer_id);
	
	
	
2023-02-21 13:21:24.187 EET [656304] ERROR:  trigger "film_fulltext_trigger" for relation "film" already exists
2023-02-21 13:21:24.187 EET [656304] STATEMENT:  CREATE TRIGGER film_fulltext_trigger BEFORE INSERT OR UPDATE ON public.film FOR EACH ROW EXECUTE PROCEDURE tsvector_update_trigger('fulltext', 'pg_catalog.english', 'title', 'description');
	
	
	
2023-02-21 13:21:24.187 EET [656304] ERROR:  trigger "last_updated" for relation "actor" already exists
2023-02-21 13:21:24.187 EET [656304] STATEMENT:  CREATE TRIGGER last_updated BEFORE UPDATE ON public.actor FOR EACH ROW EXECUTE PROCEDURE public.last_updated();
	
	
	
2023-02-21 13:21:24.187 EET [656304] ERROR:  trigger "last_updated" for relation "address" already exists
2023-02-21 13:21:24.187 EET [656304] STATEMENT:  CREATE TRIGGER last_updated BEFORE UPDATE ON public.address FOR EACH ROW EXECUTE PROCEDURE public.last_updated();
	
	
	
2023-02-21 13:21:24.188 EET [656304] ERROR:  trigger "last_updated" for relation "category" already exists
2023-02-21 13:21:24.188 EET [656304] STATEMENT:  CREATE TRIGGER last_updated BEFORE UPDATE ON public.category FOR EACH ROW EXECUTE PROCEDURE public.last_updated();
	
	
	
2023-02-21 13:21:24.188 EET [656304] ERROR:  trigger "last_updated" for relation "city" already exists
2023-02-21 13:21:24.188 EET [656304] STATEMENT:  CREATE TRIGGER last_updated BEFORE UPDATE ON public.city FOR EACH ROW EXECUTE PROCEDURE public.last_updated();
	
	
	
2023-02-21 13:21:24.188 EET [656304] ERROR:  trigger "last_updated" for relation "country" already exists
2023-02-21 13:21:24.188 EET [656304] STATEMENT:  CREATE TRIGGER last_updated BEFORE UPDATE ON public.country FOR EACH ROW EXECUTE PROCEDURE public.last_updated();
	
	
	
2023-02-21 13:21:24.188 EET [656304] ERROR:  trigger "last_updated" for relation "customer" already exists
2023-02-21 13:21:24.188 EET [656304] STATEMENT:  CREATE TRIGGER last_updated BEFORE UPDATE ON public.customer FOR EACH ROW EXECUTE PROCEDURE public.last_updated();
	
	
	
2023-02-21 13:21:24.188 EET [656304] ERROR:  trigger "last_updated" for relation "film" already exists
2023-02-21 13:21:24.188 EET [656304] STATEMENT:  CREATE TRIGGER last_updated BEFORE UPDATE ON public.film FOR EACH ROW EXECUTE PROCEDURE public.last_updated();
	
	
	
2023-02-21 13:21:24.188 EET [656304] ERROR:  trigger "last_updated" for relation "film_actor" already exists
2023-02-21 13:21:24.188 EET [656304] STATEMENT:  CREATE TRIGGER last_updated BEFORE UPDATE ON public.film_actor FOR EACH ROW EXECUTE PROCEDURE public.last_updated();
	
	
	
2023-02-21 13:21:24.188 EET [656304] ERROR:  trigger "last_updated" for relation "film_category" already exists
2023-02-21 13:21:24.188 EET [656304] STATEMENT:  CREATE TRIGGER last_updated BEFORE UPDATE ON public.film_category FOR EACH ROW EXECUTE PROCEDURE public.last_updated();
	
	
	
2023-02-21 13:21:24.188 EET [656304] ERROR:  trigger "last_updated" for relation "inventory" already exists
2023-02-21 13:21:24.188 EET [656304] STATEMENT:  CREATE TRIGGER last_updated BEFORE UPDATE ON public.inventory FOR EACH ROW EXECUTE PROCEDURE public.last_updated();
	
	
	
2023-02-21 13:21:24.188 EET [656304] ERROR:  trigger "last_updated" for relation "language" already exists
2023-02-21 13:21:24.188 EET [656304] STATEMENT:  CREATE TRIGGER last_updated BEFORE UPDATE ON public.language FOR EACH ROW EXECUTE PROCEDURE public.last_updated();
	
	
	
2023-02-21 13:21:24.189 EET [656304] ERROR:  trigger "last_updated" for relation "rental" already exists
2023-02-21 13:21:24.189 EET [656304] STATEMENT:  CREATE TRIGGER last_updated BEFORE UPDATE ON public.rental FOR EACH ROW EXECUTE PROCEDURE public.last_updated();
	
	
	
2023-02-21 13:21:24.189 EET [656304] ERROR:  trigger "last_updated" for relation "staff" already exists
2023-02-21 13:21:24.189 EET [656304] STATEMENT:  CREATE TRIGGER last_updated BEFORE UPDATE ON public.staff FOR EACH ROW EXECUTE PROCEDURE public.last_updated();
	
	
	
2023-02-21 13:21:24.189 EET [656304] ERROR:  trigger "last_updated" for relation "store" already exists
2023-02-21 13:21:24.189 EET [656304] STATEMENT:  CREATE TRIGGER last_updated BEFORE UPDATE ON public.store FOR EACH ROW EXECUTE PROCEDURE public.last_updated();
	
	
	
2023-02-21 13:21:24.189 EET [656304] ERROR:  constraint "customer_address_id_fkey" for relation "customer" already exists
2023-02-21 13:21:24.189 EET [656304] STATEMENT:  ALTER TABLE ONLY public.customer
	    ADD CONSTRAINT customer_address_id_fkey FOREIGN KEY (address_id) REFERENCES public.address(address_id) ON UPDATE CASCADE ON DELETE RESTRICT;
	
	
	
2023-02-21 13:21:24.189 EET [656304] ERROR:  constraint "film_actor_actor_id_fkey" for relation "film_actor" already exists
2023-02-21 13:21:24.189 EET [656304] STATEMENT:  ALTER TABLE ONLY public.film_actor
	    ADD CONSTRAINT film_actor_actor_id_fkey FOREIGN KEY (actor_id) REFERENCES public.actor(actor_id) ON UPDATE CASCADE ON DELETE RESTRICT;
	
	
	
2023-02-21 13:21:24.189 EET [656304] ERROR:  constraint "film_actor_film_id_fkey" for relation "film_actor" already exists
2023-02-21 13:21:24.189 EET [656304] STATEMENT:  ALTER TABLE ONLY public.film_actor
	    ADD CONSTRAINT film_actor_film_id_fkey FOREIGN KEY (film_id) REFERENCES public.film(film_id) ON UPDATE CASCADE ON DELETE RESTRICT;
	
	
	
2023-02-21 13:21:24.189 EET [656304] ERROR:  constraint "film_category_category_id_fkey" for relation "film_category" already exists
2023-02-21 13:21:24.189 EET [656304] STATEMENT:  ALTER TABLE ONLY public.film_category
	    ADD CONSTRAINT film_category_category_id_fkey FOREIGN KEY (category_id) REFERENCES public.category(category_id) ON UPDATE CASCADE ON DELETE RESTRICT;
	
	
	
2023-02-21 13:21:24.189 EET [656304] ERROR:  constraint "film_category_film_id_fkey" for relation "film_category" already exists
2023-02-21 13:21:24.189 EET [656304] STATEMENT:  ALTER TABLE ONLY public.film_category
	    ADD CONSTRAINT film_category_film_id_fkey FOREIGN KEY (film_id) REFERENCES public.film(film_id) ON UPDATE CASCADE ON DELETE RESTRICT;
	
	
	
2023-02-21 13:21:24.190 EET [656304] ERROR:  constraint "film_language_id_fkey" for relation "film" already exists
2023-02-21 13:21:24.190 EET [656304] STATEMENT:  ALTER TABLE ONLY public.film
	    ADD CONSTRAINT film_language_id_fkey FOREIGN KEY (language_id) REFERENCES public.language(language_id) ON UPDATE CASCADE ON DELETE RESTRICT;
	
	
	
2023-02-21 13:21:24.190 EET [656304] ERROR:  constraint "fk_address_city" for relation "address" already exists
2023-02-21 13:21:24.190 EET [656304] STATEMENT:  ALTER TABLE ONLY public.address
	    ADD CONSTRAINT fk_address_city FOREIGN KEY (city_id) REFERENCES public.city(city_id);
	
	
	
2023-02-21 13:21:24.190 EET [656304] ERROR:  constraint "fk_city" for relation "city" already exists
2023-02-21 13:21:24.190 EET [656304] STATEMENT:  ALTER TABLE ONLY public.city
	    ADD CONSTRAINT fk_city FOREIGN KEY (country_id) REFERENCES public.country(country_id);
	
	
	
2023-02-21 13:21:24.190 EET [656304] ERROR:  constraint "inventory_film_id_fkey" for relation "inventory" already exists
2023-02-21 13:21:24.190 EET [656304] STATEMENT:  ALTER TABLE ONLY public.inventory
	    ADD CONSTRAINT inventory_film_id_fkey FOREIGN KEY (film_id) REFERENCES public.film(film_id) ON UPDATE CASCADE ON DELETE RESTRICT;
	
	
	
2023-02-21 13:21:24.190 EET [656304] ERROR:  constraint "payment_customer_id_fkey" for relation "payment" already exists
2023-02-21 13:21:24.190 EET [656304] STATEMENT:  ALTER TABLE ONLY public.payment
	    ADD CONSTRAINT payment_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES public.customer(customer_id) ON UPDATE CASCADE ON DELETE RESTRICT;
	
	
	
2023-02-21 13:21:24.190 EET [656304] ERROR:  constraint "payment_rental_id_fkey" for relation "payment" already exists
2023-02-21 13:21:24.190 EET [656304] STATEMENT:  ALTER TABLE ONLY public.payment
	    ADD CONSTRAINT payment_rental_id_fkey FOREIGN KEY (rental_id) REFERENCES public.rental(rental_id) ON UPDATE CASCADE ON DELETE SET NULL;
	
	
	
2023-02-21 13:21:24.190 EET [656304] ERROR:  constraint "payment_staff_id_fkey" for relation "payment" already exists
2023-02-21 13:21:24.190 EET [656304] STATEMENT:  ALTER TABLE ONLY public.payment
	    ADD CONSTRAINT payment_staff_id_fkey FOREIGN KEY (staff_id) REFERENCES public.staff(staff_id) ON UPDATE CASCADE ON DELETE RESTRICT;
	
	
	
2023-02-21 13:21:24.191 EET [656304] ERROR:  constraint "rental_customer_id_fkey" for relation "rental" already exists
2023-02-21 13:21:24.191 EET [656304] STATEMENT:  ALTER TABLE ONLY public.rental
	    ADD CONSTRAINT rental_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES public.customer(customer_id) ON UPDATE CASCADE ON DELETE RESTRICT;
	
	
	
2023-02-21 13:21:24.191 EET [656304] ERROR:  constraint "rental_inventory_id_fkey" for relation "rental" already exists
2023-02-21 13:21:24.191 EET [656304] STATEMENT:  ALTER TABLE ONLY public.rental
	    ADD CONSTRAINT rental_inventory_id_fkey FOREIGN KEY (inventory_id) REFERENCES public.inventory(inventory_id) ON UPDATE CASCADE ON DELETE RESTRICT;
	
	
	
2023-02-21 13:21:24.191 EET [656304] ERROR:  constraint "rental_staff_id_key" for relation "rental" already exists
2023-02-21 13:21:24.191 EET [656304] STATEMENT:  ALTER TABLE ONLY public.rental
	    ADD CONSTRAINT rental_staff_id_key FOREIGN KEY (staff_id) REFERENCES public.staff(staff_id);
	
	
	
2023-02-21 13:21:24.191 EET [656304] ERROR:  constraint "staff_address_id_fkey" for relation "staff" already exists
2023-02-21 13:21:24.191 EET [656304] STATEMENT:  ALTER TABLE ONLY public.staff
	    ADD CONSTRAINT staff_address_id_fkey FOREIGN KEY (address_id) REFERENCES public.address(address_id) ON UPDATE CASCADE ON DELETE RESTRICT;
	
	
	
2023-02-21 13:21:24.191 EET [656304] ERROR:  constraint "store_address_id_fkey" for relation "store" already exists
2023-02-21 13:21:24.191 EET [656304] STATEMENT:  ALTER TABLE ONLY public.store
	    ADD CONSTRAINT store_address_id_fkey FOREIGN KEY (address_id) REFERENCES public.address(address_id) ON UPDATE CASCADE ON DELETE RESTRICT;
	
	
	
2023-02-21 13:21:24.191 EET [656304] ERROR:  constraint "store_manager_staff_id_fkey" for relation "store" already exists
2023-02-21 13:21:24.191 EET [656304] STATEMENT:  ALTER TABLE ONLY public.store
	    ADD CONSTRAINT store_manager_staff_id_fkey FOREIGN KEY (manager_staff_id) REFERENCES public.staff(staff_id) ON UPDATE CASCADE ON DELETE RESTRICT;
	
	
	
2023-02-21 13:24:11.150 EET [656695] ERROR:  type "mpaa_rating" already exists
2023-02-21 13:24:11.150 EET [656695] STATEMENT:  CREATE TYPE public.mpaa_rating AS ENUM (
	    'G',
	    'PG',
	    'PG-13',
	    'R',
	    'NC-17'
	);
	
	
	
2023-02-21 13:24:11.150 EET [656695] ERROR:  type "year" already exists
2023-02-21 13:24:11.150 EET [656695] STATEMENT:  CREATE DOMAIN public.year AS integer
		CONSTRAINT year_check CHECK (((VALUE >= 1901) AND (VALUE <= 2155)));
	
	
	
2023-02-21 13:24:11.151 EET [656695] ERROR:  function "_group_concat" already exists with same argument types
2023-02-21 13:24:11.151 EET [656695] STATEMENT:  CREATE FUNCTION public._group_concat(text, text) RETURNS text
	    LANGUAGE sql IMMUTABLE
	    AS $_$
	SELECT CASE
	  WHEN $2 IS NULL THEN $1
	  WHEN $1 IS NULL THEN $2
	  ELSE $1 || ', ' || $2
	END
	$_$;
	
	
	
2023-02-21 13:24:11.151 EET [656695] ERROR:  function "film_in_stock" already exists with same argument types
2023-02-21 13:24:11.151 EET [656695] STATEMENT:  CREATE FUNCTION public.film_in_stock(p_film_id integer, p_store_id integer, OUT p_film_count integer) RETURNS SETOF integer
	    LANGUAGE sql
	    AS $_$
	     SELECT inventory_id
	     FROM inventory
	     WHERE film_id = $1
	     AND store_id = $2
	     AND inventory_in_stock(inventory_id);
	$_$;
	
	
	
2023-02-21 13:24:11.151 EET [656695] ERROR:  function "film_not_in_stock" already exists with same argument types
2023-02-21 13:24:11.151 EET [656695] STATEMENT:  CREATE FUNCTION public.film_not_in_stock(p_film_id integer, p_store_id integer, OUT p_film_count integer) RETURNS SETOF integer
	    LANGUAGE sql
	    AS $_$
	    SELECT inventory_id
	    FROM inventory
	    WHERE film_id = $1
	    AND store_id = $2
	    AND NOT inventory_in_stock(inventory_id);
	$_$;
	
	
	
2023-02-21 13:24:11.151 EET [656695] ERROR:  function "get_customer_balance" already exists with same argument types
2023-02-21 13:24:11.151 EET [656695] STATEMENT:  CREATE FUNCTION public.get_customer_balance(p_customer_id integer, p_effective_date timestamp without time zone) RETURNS numeric
	    LANGUAGE plpgsql
	    AS $$
	       --#OK, WE NEED TO CALCULATE THE CURRENT BALANCE GIVEN A CUSTOMER_ID AND A DATE
	       --#THAT WE WANT THE BALANCE TO BE EFFECTIVE FOR. THE BALANCE IS:
	       --#   1) RENTAL FEES FOR ALL PREVIOUS RENTALS
	       --#   2) ONE DOLLAR FOR EVERY DAY THE PREVIOUS RENTALS ARE OVERDUE
	       --#   3) IF A FILM IS MORE THAN RENTAL_DURATION * 2 OVERDUE, CHARGE THE REPLACEMENT_COST
	       --#   4) SUBTRACT ALL PAYMENTS MADE BEFORE THE DATE SPECIFIED
	DECLARE
	    v_rentfees DECIMAL(5,2); --#FEES PAID TO RENT THE VIDEOS INITIALLY
	    v_overfees INTEGER;      --#LATE FEES FOR PRIOR RENTALS
	    v_payments DECIMAL(5,2); --#SUM OF PAYMENTS MADE PREVIOUSLY
	BEGIN
	    SELECT COALESCE(SUM(film.rental_rate),0) INTO v_rentfees
	    FROM film, inventory, rental
	    WHERE film.film_id = inventory.film_id
	      AND inventory.inventory_id = rental.inventory_id
	      AND rental.rental_date <= p_effective_date
	      AND rental.customer_id = p_customer_id;
	
	    SELECT COALESCE(SUM(IF((rental.return_date - rental.rental_date) > (film.rental_duration * '1 day'::interval),
	        ((rental.return_date - rental.rental_date) - (film.rental_duration * '1 day'::interval)),0)),0) INTO v_overfees
	    FROM rental, inventory, film
	    WHERE film.film_id = inventory.film_id
	      AND inventory.inventory_id = rental.inventory_id
	      AND rental.rental_date <= p_effective_date
	      AND rental.customer_id = p_customer_id;
	
	    SELECT COALESCE(SUM(payment.amount),0) INTO v_payments
	    FROM payment
	    WHERE payment.payment_date <= p_effective_date
	    AND payment.customer_id = p_customer_id;
	
	    RETURN v_rentfees + v_overfees - v_payments;
	END
	$$;
	
	
	
2023-02-21 13:24:11.152 EET [656695] ERROR:  function "inventory_held_by_customer" already exists with same argument types
2023-02-21 13:24:11.152 EET [656695] STATEMENT:  CREATE FUNCTION public.inventory_held_by_customer(p_inventory_id integer) RETURNS integer
	    LANGUAGE plpgsql
	    AS $$
	DECLARE
	    v_customer_id INTEGER;
	BEGIN
	
	  SELECT customer_id INTO v_customer_id
	  FROM rental
	  WHERE return_date IS NULL
	  AND inventory_id = p_inventory_id;
	
	  RETURN v_customer_id;
	END $$;
	
	
	
2023-02-21 13:24:11.152 EET [656695] ERROR:  function "inventory_in_stock" already exists with same argument types
2023-02-21 13:24:11.152 EET [656695] STATEMENT:  CREATE FUNCTION public.inventory_in_stock(p_inventory_id integer) RETURNS boolean
	    LANGUAGE plpgsql
	    AS $$
	DECLARE
	    v_rentals INTEGER;
	    v_out     INTEGER;
	BEGIN
	    -- AN ITEM IS IN-STOCK IF THERE ARE EITHER NO ROWS IN THE rental TABLE
	    -- FOR THE ITEM OR ALL ROWS HAVE return_date POPULATED
	
	    SELECT count(*) INTO v_rentals
	    FROM rental
	    WHERE inventory_id = p_inventory_id;
	
	    IF v_rentals = 0 THEN
	      RETURN TRUE;
	    END IF;
	
	    SELECT COUNT(rental_id) INTO v_out
	    FROM inventory LEFT JOIN rental USING(inventory_id)
	    WHERE inventory.inventory_id = p_inventory_id
	    AND rental.return_date IS NULL;
	
	    IF v_out > 0 THEN
	      RETURN FALSE;
	    ELSE
	      RETURN TRUE;
	    END IF;
	END $$;
	
	
	
2023-02-21 13:24:11.152 EET [656695] ERROR:  function "last_day" already exists with same argument types
2023-02-21 13:24:11.152 EET [656695] STATEMENT:  CREATE FUNCTION public.last_day(timestamp without time zone) RETURNS date
	    LANGUAGE sql IMMUTABLE STRICT
	    AS $_$
	  SELECT CASE
	    WHEN EXTRACT(MONTH FROM $1) = 12 THEN
	      (((EXTRACT(YEAR FROM $1) + 1) operator(pg_catalog.||) '-01-01')::date - INTERVAL '1 day')::date
	    ELSE
	      ((EXTRACT(YEAR FROM $1) operator(pg_catalog.||) '-' operator(pg_catalog.||) (EXTRACT(MONTH FROM $1) + 1) operator(pg_catalog.||) '-01')::date - INTERVAL '1 day')::date
	    END
	$_$;
	
	
	
2023-02-21 13:24:11.153 EET [656695] ERROR:  function "last_updated" already exists with same argument types
2023-02-21 13:24:11.153 EET [656695] STATEMENT:  CREATE FUNCTION public.last_updated() RETURNS trigger
	    LANGUAGE plpgsql
	    AS $$
	BEGIN
	    NEW.last_update = CURRENT_TIMESTAMP;
	    RETURN NEW;
	END $$;
	
	
	
2023-02-21 13:24:11.153 EET [656695] ERROR:  relation "customer_customer_id_seq" already exists
2023-02-21 13:24:11.153 EET [656695] STATEMENT:  CREATE SEQUENCE public.customer_customer_id_seq
	    START WITH 1
	    INCREMENT BY 1
	    NO MINVALUE
	    NO MAXVALUE
	    CACHE 1;
	
	
	
2023-02-21 13:24:11.158 EET [656695] ERROR:  relation "customer" already exists
2023-02-21 13:24:11.158 EET [656695] STATEMENT:  CREATE TABLE public.customer (
	    customer_id integer DEFAULT nextval('public.customer_customer_id_seq'::regclass) NOT NULL,
	    store_id smallint NOT NULL,
	    first_name character varying(45) NOT NULL,
	    last_name character varying(45) NOT NULL,
	    email character varying(50),
	    address_id smallint NOT NULL,
	    activebool boolean DEFAULT true NOT NULL,
	    create_date date DEFAULT ('now'::text)::date NOT NULL,
	    last_update timestamp without time zone DEFAULT now(),
	    active integer
	);
	
	
	
2023-02-21 13:24:11.163 EET [656695] ERROR:  function "rewards_report" already exists with same argument types
2023-02-21 13:24:11.163 EET [656695] STATEMENT:  CREATE FUNCTION public.rewards_report(min_monthly_purchases integer, min_dollar_amount_purchased numeric) RETURNS SETOF public.customer
	    LANGUAGE plpgsql SECURITY DEFINER
	    AS $_$
	DECLARE
	    last_month_start DATE;
	    last_month_end DATE;
	rr RECORD;
	tmpSQL TEXT;
	BEGIN
	
	    /* Some sanity checks... */
	    IF min_monthly_purchases = 0 THEN
	        RAISE EXCEPTION 'Minimum monthly purchases parameter must be > 0';
	    END IF;
	    IF min_dollar_amount_purchased = 0.00 THEN
	        RAISE EXCEPTION 'Minimum monthly dollar amount purchased parameter must be > $0.00';
	    END IF;
	
	    last_month_start := CURRENT_DATE - '3 month'::interval;
	    last_month_start := to_date((extract(YEAR FROM last_month_start) || '-' || extract(MONTH FROM last_month_start) || '-01'),'YYYY-MM-DD');
	    last_month_end := LAST_DAY(last_month_start);
	
	    /*
	    Create a temporary storage area for Customer IDs.
	    */
	    CREATE TEMPORARY TABLE tmpCustomer (customer_id INTEGER NOT NULL PRIMARY KEY);
	
	    /*
	    Find all customers meeting the monthly purchase requirements
	    */
	
	    tmpSQL := 'INSERT INTO tmpCustomer (customer_id)
	        SELECT p.customer_id
	        FROM payment AS p
	        WHERE DATE(p.payment_date) BETWEEN '||quote_literal(last_month_start) ||' AND '|| quote_literal(last_month_end) || '
	        GROUP BY customer_id
	        HAVING SUM(p.amount) > '|| min_dollar_amount_purchased || '
	        AND COUNT(customer_id) > ' ||min_monthly_purchases ;
	
	    EXECUTE tmpSQL;
	
	    /*
	    Output ALL customer information of matching rewardees.
	    Customize output as needed.
	    */
	    FOR rr IN EXECUTE 'SELECT c.* FROM tmpCustomer AS t INNER JOIN customer AS c ON t.customer_id = c.customer_id' LOOP
	        RETURN NEXT rr;
	    END LOOP;
	
	    /* Clean up */
	    tmpSQL := 'DROP TABLE tmpCustomer';
	    EXECUTE tmpSQL;
	
	RETURN;
	END
	$_$;
	
	
	
2023-02-21 13:24:11.164 EET [656695] ERROR:  function "group_concat" already exists with same argument types
2023-02-21 13:24:11.164 EET [656695] STATEMENT:  CREATE AGGREGATE public.group_concat(text) (
	    SFUNC = public._group_concat,
	    STYPE = text
	);
	
	
	
2023-02-21 13:24:11.165 EET [656695] ERROR:  relation "actor_actor_id_seq" already exists
2023-02-21 13:24:11.165 EET [656695] STATEMENT:  CREATE SEQUENCE public.actor_actor_id_seq
	    START WITH 1
	    INCREMENT BY 1
	    NO MINVALUE
	    NO MAXVALUE
	    CACHE 1;
	
	
	
2023-02-21 13:24:11.170 EET [656695] ERROR:  relation "actor" already exists
2023-02-21 13:24:11.170 EET [656695] STATEMENT:  CREATE TABLE public.actor (
	    actor_id integer DEFAULT nextval('public.actor_actor_id_seq'::regclass) NOT NULL,
	    first_name character varying(45) NOT NULL,
	    last_name character varying(45) NOT NULL,
	    last_update timestamp without time zone DEFAULT now() NOT NULL
	);
	
	
	
2023-02-21 13:24:11.175 EET [656695] ERROR:  relation "category_category_id_seq" already exists
2023-02-21 13:24:11.175 EET [656695] STATEMENT:  CREATE SEQUENCE public.category_category_id_seq
	    START WITH 1
	    INCREMENT BY 1
	    NO MINVALUE
	    NO MAXVALUE
	    CACHE 1;
	
	
	
2023-02-21 13:24:11.180 EET [656695] ERROR:  relation "category" already exists
2023-02-21 13:24:11.180 EET [656695] STATEMENT:  CREATE TABLE public.category (
	    category_id integer DEFAULT nextval('public.category_category_id_seq'::regclass) NOT NULL,
	    name character varying(25) NOT NULL,
	    last_update timestamp without time zone DEFAULT now() NOT NULL
	);
	
	
	
2023-02-21 13:24:11.185 EET [656695] ERROR:  relation "film_film_id_seq" already exists
2023-02-21 13:24:11.185 EET [656695] STATEMENT:  CREATE SEQUENCE public.film_film_id_seq
	    START WITH 1
	    INCREMENT BY 1
	    NO MINVALUE
	    NO MAXVALUE
	    CACHE 1;
	
	
	
2023-02-21 13:24:11.191 EET [656695] ERROR:  relation "film" already exists
2023-02-21 13:24:11.191 EET [656695] STATEMENT:  CREATE TABLE public.film (
	    film_id integer DEFAULT nextval('public.film_film_id_seq'::regclass) NOT NULL,
	    title character varying(255) NOT NULL,
	    description text,
	    release_year public.year,
	    language_id smallint NOT NULL,
	    rental_duration smallint DEFAULT 3 NOT NULL,
	    rental_rate numeric(4,2) DEFAULT 4.99 NOT NULL,
	    length smallint,
	    replacement_cost numeric(5,2) DEFAULT 19.99 NOT NULL,
	    rating public.mpaa_rating DEFAULT 'G'::public.mpaa_rating,
	    last_update timestamp without time zone DEFAULT now() NOT NULL,
	    special_features text[],
	    fulltext tsvector NOT NULL
	);
	
	
	
2023-02-21 13:24:11.196 EET [656695] ERROR:  relation "film_actor" already exists
2023-02-21 13:24:11.196 EET [656695] STATEMENT:  CREATE TABLE public.film_actor (
	    actor_id smallint NOT NULL,
	    film_id smallint NOT NULL,
	    last_update timestamp without time zone DEFAULT now() NOT NULL
	);
	
	
	
2023-02-21 13:24:11.201 EET [656695] ERROR:  relation "film_category" already exists
2023-02-21 13:24:11.201 EET [656695] STATEMENT:  CREATE TABLE public.film_category (
	    film_id smallint NOT NULL,
	    category_id smallint NOT NULL,
	    last_update timestamp without time zone DEFAULT now() NOT NULL
	);
	
	
	
2023-02-21 13:24:11.208 EET [656695] ERROR:  relation "actor_info" already exists
2023-02-21 13:24:11.208 EET [656695] STATEMENT:  CREATE VIEW public.actor_info AS
	 SELECT a.actor_id,
	    a.first_name,
	    a.last_name,
	    public.group_concat(DISTINCT (((c.name)::text || ': '::text) || ( SELECT public.group_concat((f.title)::text) AS group_concat
	           FROM ((public.film f
	             JOIN public.film_category fc_1 ON ((f.film_id = fc_1.film_id)))
	             JOIN public.film_actor fa_1 ON ((f.film_id = fa_1.film_id)))
	          WHERE ((fc_1.category_id = c.category_id) AND (fa_1.actor_id = a.actor_id))
	          GROUP BY fa_1.actor_id))) AS film_info
	   FROM (((public.actor a
	     LEFT JOIN public.film_actor fa ON ((a.actor_id = fa.actor_id)))
	     LEFT JOIN public.film_category fc ON ((fa.film_id = fc.film_id)))
	     LEFT JOIN public.category c ON ((fc.category_id = c.category_id)))
	  GROUP BY a.actor_id, a.first_name, a.last_name;
	
	
	
2023-02-21 13:24:11.214 EET [656695] ERROR:  relation "address_address_id_seq" already exists
2023-02-21 13:24:11.214 EET [656695] STATEMENT:  CREATE SEQUENCE public.address_address_id_seq
	    START WITH 1
	    INCREMENT BY 1
	    NO MINVALUE
	    NO MAXVALUE
	    CACHE 1;
	
	
	
2023-02-21 13:24:11.219 EET [656695] ERROR:  relation "address" already exists
2023-02-21 13:24:11.219 EET [656695] STATEMENT:  CREATE TABLE public.address (
	    address_id integer DEFAULT nextval('public.address_address_id_seq'::regclass) NOT NULL,
	    address character varying(50) NOT NULL,
	    address2 character varying(50),
	    district character varying(20) NOT NULL,
	    city_id smallint NOT NULL,
	    postal_code character varying(10),
	    phone character varying(20) NOT NULL,
	    last_update timestamp without time zone DEFAULT now() NOT NULL
	);
	
	
	
2023-02-21 13:24:11.224 EET [656695] ERROR:  relation "city_city_id_seq" already exists
2023-02-21 13:24:11.224 EET [656695] STATEMENT:  CREATE SEQUENCE public.city_city_id_seq
	    START WITH 1
	    INCREMENT BY 1
	    NO MINVALUE
	    NO MAXVALUE
	    CACHE 1;
	
	
	
2023-02-21 13:24:11.229 EET [656695] ERROR:  relation "city" already exists
2023-02-21 13:24:11.229 EET [656695] STATEMENT:  CREATE TABLE public.city (
	    city_id integer DEFAULT nextval('public.city_city_id_seq'::regclass) NOT NULL,
	    city character varying(50) NOT NULL,
	    country_id smallint NOT NULL,
	    last_update timestamp without time zone DEFAULT now() NOT NULL
	);
	
	
	
2023-02-21 13:24:11.234 EET [656695] ERROR:  relation "country_country_id_seq" already exists
2023-02-21 13:24:11.234 EET [656695] STATEMENT:  CREATE SEQUENCE public.country_country_id_seq
	    START WITH 1
	    INCREMENT BY 1
	    NO MINVALUE
	    NO MAXVALUE
	    CACHE 1;
	
	
	
2023-02-21 13:24:11.238 EET [656695] ERROR:  relation "country" already exists
2023-02-21 13:24:11.238 EET [656695] STATEMENT:  CREATE TABLE public.country (
	    country_id integer DEFAULT nextval('public.country_country_id_seq'::regclass) NOT NULL,
	    country character varying(50) NOT NULL,
	    last_update timestamp without time zone DEFAULT now() NOT NULL
	);
	
	
	
2023-02-21 13:24:11.246 EET [656695] ERROR:  relation "customer_list" already exists
2023-02-21 13:24:11.246 EET [656695] STATEMENT:  CREATE VIEW public.customer_list AS
	 SELECT cu.customer_id AS id,
	    (((cu.first_name)::text || ' '::text) || (cu.last_name)::text) AS name,
	    a.address,
	    a.postal_code AS "zip code",
	    a.phone,
	    city.city,
	    country.country,
	        CASE
	            WHEN cu.activebool THEN 'active'::text
	            ELSE ''::text
	        END AS notes,
	    cu.store_id AS sid
	   FROM (((public.customer cu
	     JOIN public.address a ON ((cu.address_id = a.address_id)))
	     JOIN public.city ON ((a.city_id = city.city_id)))
	     JOIN public.country ON ((city.country_id = country.country_id)));
	
	
	
2023-02-21 13:24:11.253 EET [656695] ERROR:  relation "film_list" already exists
2023-02-21 13:24:11.253 EET [656695] STATEMENT:  CREATE VIEW public.film_list AS
	 SELECT film.film_id AS fid,
	    film.title,
	    film.description,
	    category.name AS category,
	    film.rental_rate AS price,
	    film.length,
	    film.rating,
	    public.group_concat((((actor.first_name)::text || ' '::text) || (actor.last_name)::text)) AS actors
	   FROM ((((public.category
	     LEFT JOIN public.film_category ON ((category.category_id = film_category.category_id)))
	     LEFT JOIN public.film ON ((film_category.film_id = film.film_id)))
	     JOIN public.film_actor ON ((film.film_id = film_actor.film_id)))
	     JOIN public.actor ON ((film_actor.actor_id = actor.actor_id)))
	  GROUP BY film.film_id, film.title, film.description, category.name, film.rental_rate, film.length, film.rating;
	
	
	
2023-02-21 13:24:11.257 EET [656695] ERROR:  relation "inventory_inventory_id_seq" already exists
2023-02-21 13:24:11.257 EET [656695] STATEMENT:  CREATE SEQUENCE public.inventory_inventory_id_seq
	    START WITH 1
	    INCREMENT BY 1
	    NO MINVALUE
	    NO MAXVALUE
	    CACHE 1;
	
	
	
2023-02-21 13:24:11.262 EET [656695] ERROR:  relation "inventory" already exists
2023-02-21 13:24:11.262 EET [656695] STATEMENT:  CREATE TABLE public.inventory (
	    inventory_id integer DEFAULT nextval('public.inventory_inventory_id_seq'::regclass) NOT NULL,
	    film_id smallint NOT NULL,
	    store_id smallint NOT NULL,
	    last_update timestamp without time zone DEFAULT now() NOT NULL
	);
	
	
	
2023-02-21 13:24:11.266 EET [656695] ERROR:  relation "language_language_id_seq" already exists
2023-02-21 13:24:11.266 EET [656695] STATEMENT:  CREATE SEQUENCE public.language_language_id_seq
	    START WITH 1
	    INCREMENT BY 1
	    NO MINVALUE
	    NO MAXVALUE
	    CACHE 1;
	
	
	
2023-02-21 13:24:11.270 EET [656695] ERROR:  relation "language" already exists
2023-02-21 13:24:11.270 EET [656695] STATEMENT:  CREATE TABLE public.language (
	    language_id integer DEFAULT nextval('public.language_language_id_seq'::regclass) NOT NULL,
	    name character(20) NOT NULL,
	    last_update timestamp without time zone DEFAULT now() NOT NULL
	);
	
	
	
2023-02-21 13:24:11.276 EET [656695] ERROR:  relation "nicer_but_slower_film_list" already exists
2023-02-21 13:24:11.276 EET [656695] STATEMENT:  CREATE VIEW public.nicer_but_slower_film_list AS
	 SELECT film.film_id AS fid,
	    film.title,
	    film.description,
	    category.name AS category,
	    film.rental_rate AS price,
	    film.length,
	    film.rating,
	    public.group_concat((((upper("substring"((actor.first_name)::text, 1, 1)) || lower("substring"((actor.first_name)::text, 2))) || upper("substring"((actor.last_name)::text, 1, 1))) || lower("substring"((actor.last_name)::text, 2)))) AS actors
	   FROM ((((public.category
	     LEFT JOIN public.film_category ON ((category.category_id = film_category.category_id)))
	     LEFT JOIN public.film ON ((film_category.film_id = film.film_id)))
	     JOIN public.film_actor ON ((film.film_id = film_actor.film_id)))
	     JOIN public.actor ON ((film_actor.actor_id = actor.actor_id)))
	  GROUP BY film.film_id, film.title, film.description, category.name, film.rental_rate, film.length, film.rating;
	
	
	
2023-02-21 13:24:11.282 EET [656695] ERROR:  relation "payment_payment_id_seq" already exists
2023-02-21 13:24:11.282 EET [656695] STATEMENT:  CREATE SEQUENCE public.payment_payment_id_seq
	    START WITH 1
	    INCREMENT BY 1
	    NO MINVALUE
	    NO MAXVALUE
	    CACHE 1;
	
	
	
2023-02-21 13:24:11.287 EET [656695] ERROR:  relation "payment" already exists
2023-02-21 13:24:11.287 EET [656695] STATEMENT:  CREATE TABLE public.payment (
	    payment_id integer DEFAULT nextval('public.payment_payment_id_seq'::regclass) NOT NULL,
	    customer_id smallint NOT NULL,
	    staff_id smallint NOT NULL,
	    rental_id integer NOT NULL,
	    amount numeric(5,2) NOT NULL,
	    payment_date timestamp without time zone NOT NULL
	);
	
	
	
2023-02-21 13:24:11.292 EET [656695] ERROR:  relation "rental_rental_id_seq" already exists
2023-02-21 13:24:11.292 EET [656695] STATEMENT:  CREATE SEQUENCE public.rental_rental_id_seq
	    START WITH 1
	    INCREMENT BY 1
	    NO MINVALUE
	    NO MAXVALUE
	    CACHE 1;
	
	
	
2023-02-21 13:24:11.296 EET [656695] ERROR:  relation "rental" already exists
2023-02-21 13:24:11.296 EET [656695] STATEMENT:  CREATE TABLE public.rental (
	    rental_id integer DEFAULT nextval('public.rental_rental_id_seq'::regclass) NOT NULL,
	    rental_date timestamp without time zone NOT NULL,
	    inventory_id integer NOT NULL,
	    customer_id smallint NOT NULL,
	    return_date timestamp without time zone,
	    staff_id smallint NOT NULL,
	    last_update timestamp without time zone DEFAULT now() NOT NULL
	);
	
	
	
2023-02-21 13:24:11.302 EET [656695] ERROR:  relation "sales_by_film_category" already exists
2023-02-21 13:24:11.302 EET [656695] STATEMENT:  CREATE VIEW public.sales_by_film_category AS
	 SELECT c.name AS category,
	    sum(p.amount) AS total_sales
	   FROM (((((public.payment p
	     JOIN public.rental r ON ((p.rental_id = r.rental_id)))
	     JOIN public.inventory i ON ((r.inventory_id = i.inventory_id)))
	     JOIN public.film f ON ((i.film_id = f.film_id)))
	     JOIN public.film_category fc ON ((f.film_id = fc.film_id)))
	     JOIN public.category c ON ((fc.category_id = c.category_id)))
	  GROUP BY c.name
	  ORDER BY (sum(p.amount)) DESC;
	
	
	
2023-02-21 13:24:11.308 EET [656695] ERROR:  relation "staff_staff_id_seq" already exists
2023-02-21 13:24:11.308 EET [656695] STATEMENT:  CREATE SEQUENCE public.staff_staff_id_seq
	    START WITH 1
	    INCREMENT BY 1
	    NO MINVALUE
	    NO MAXVALUE
	    CACHE 1;
	
	
	
2023-02-21 13:24:11.313 EET [656695] ERROR:  relation "staff" already exists
2023-02-21 13:24:11.313 EET [656695] STATEMENT:  CREATE TABLE public.staff (
	    staff_id integer DEFAULT nextval('public.staff_staff_id_seq'::regclass) NOT NULL,
	    first_name character varying(45) NOT NULL,
	    last_name character varying(45) NOT NULL,
	    address_id smallint NOT NULL,
	    email character varying(50),
	    store_id smallint NOT NULL,
	    active boolean DEFAULT true NOT NULL,
	    username character varying(16) NOT NULL,
	    password character varying(40),
	    last_update timestamp without time zone DEFAULT now() NOT NULL,
	    picture bytea
	);
	
	
	
2023-02-21 13:24:11.317 EET [656695] ERROR:  relation "store_store_id_seq" already exists
2023-02-21 13:24:11.317 EET [656695] STATEMENT:  CREATE SEQUENCE public.store_store_id_seq
	    START WITH 1
	    INCREMENT BY 1
	    NO MINVALUE
	    NO MAXVALUE
	    CACHE 1;
	
	
	
2023-02-21 13:24:11.322 EET [656695] ERROR:  relation "store" already exists
2023-02-21 13:24:11.322 EET [656695] STATEMENT:  CREATE TABLE public.store (
	    store_id integer DEFAULT nextval('public.store_store_id_seq'::regclass) NOT NULL,
	    manager_staff_id smallint NOT NULL,
	    address_id smallint NOT NULL,
	    last_update timestamp without time zone DEFAULT now() NOT NULL
	);
	
	
	
2023-02-21 13:24:11.328 EET [656695] ERROR:  relation "sales_by_store" already exists
2023-02-21 13:24:11.328 EET [656695] STATEMENT:  CREATE VIEW public.sales_by_store AS
	 SELECT (((c.city)::text || ','::text) || (cy.country)::text) AS store,
	    (((m.first_name)::text || ' '::text) || (m.last_name)::text) AS manager,
	    sum(p.amount) AS total_sales
	   FROM (((((((public.payment p
	     JOIN public.rental r ON ((p.rental_id = r.rental_id)))
	     JOIN public.inventory i ON ((r.inventory_id = i.inventory_id)))
	     JOIN public.store s ON ((i.store_id = s.store_id)))
	     JOIN public.address a ON ((s.address_id = a.address_id)))
	     JOIN public.city c ON ((a.city_id = c.city_id)))
	     JOIN public.country cy ON ((c.country_id = cy.country_id)))
	     JOIN public.staff m ON ((s.manager_staff_id = m.staff_id)))
	  GROUP BY cy.country, c.city, s.store_id, m.first_name, m.last_name
	  ORDER BY cy.country, c.city;
	
	
	
2023-02-21 13:24:11.334 EET [656695] ERROR:  relation "staff_list" already exists
2023-02-21 13:24:11.334 EET [656695] STATEMENT:  CREATE VIEW public.staff_list AS
	 SELECT s.staff_id AS id,
	    (((s.first_name)::text || ' '::text) || (s.last_name)::text) AS name,
	    a.address,
	    a.postal_code AS "zip code",
	    a.phone,
	    city.city,
	    country.country,
	    s.store_id AS sid
	   FROM (((public.staff s
	     JOIN public.address a ON ((s.address_id = a.address_id)))
	     JOIN public.city ON ((a.city_id = city.city_id)))
	     JOIN public.country ON ((city.country_id = country.country_id)));
	
	
	
2023-02-21 13:24:11.342 EET [656695] ERROR:  duplicate key value violates unique constraint "actor_pkey"
2023-02-21 13:24:11.342 EET [656695] DETAIL:  Key (actor_id)=(1) already exists.
2023-02-21 13:24:11.342 EET [656695] CONTEXT:  COPY actor, line 1
2023-02-21 13:24:11.342 EET [656695] STATEMENT:  COPY public.actor (actor_id, first_name, last_name, last_update) FROM stdin;
	
2023-02-21 13:24:11.348 EET [656695] ERROR:  duplicate key value violates unique constraint "address_pkey"
2023-02-21 13:24:11.348 EET [656695] DETAIL:  Key (address_id)=(1) already exists.
2023-02-21 13:24:11.348 EET [656695] CONTEXT:  COPY address, line 1
2023-02-21 13:24:11.348 EET [656695] STATEMENT:  COPY public.address (address_id, address, address2, district, city_id, postal_code, phone, last_update) FROM stdin;
	
2023-02-21 13:24:11.349 EET [656695] ERROR:  duplicate key value violates unique constraint "category_pkey"
2023-02-21 13:24:11.349 EET [656695] DETAIL:  Key (category_id)=(1) already exists.
2023-02-21 13:24:11.349 EET [656695] CONTEXT:  COPY category, line 1
2023-02-21 13:24:11.349 EET [656695] STATEMENT:  COPY public.category (category_id, name, last_update) FROM stdin;
	
2023-02-21 13:24:11.354 EET [656695] ERROR:  duplicate key value violates unique constraint "city_pkey"
2023-02-21 13:24:11.354 EET [656695] DETAIL:  Key (city_id)=(1) already exists.
2023-02-21 13:24:11.354 EET [656695] CONTEXT:  COPY city, line 1
2023-02-21 13:24:11.354 EET [656695] STATEMENT:  COPY public.city (city_id, city, country_id, last_update) FROM stdin;
	
2023-02-21 13:24:11.355 EET [656695] ERROR:  duplicate key value violates unique constraint "country_pkey"
2023-02-21 13:24:11.355 EET [656695] DETAIL:  Key (country_id)=(1) already exists.
2023-02-21 13:24:11.355 EET [656695] CONTEXT:  COPY country, line 1
2023-02-21 13:24:11.355 EET [656695] STATEMENT:  COPY public.country (country_id, country, last_update) FROM stdin;
	
2023-02-21 13:24:11.360 EET [656695] ERROR:  duplicate key value violates unique constraint "customer_pkey"
2023-02-21 13:24:11.360 EET [656695] DETAIL:  Key (customer_id)=(524) already exists.
2023-02-21 13:24:11.360 EET [656695] CONTEXT:  COPY customer, line 1
2023-02-21 13:24:11.360 EET [656695] STATEMENT:  COPY public.customer (customer_id, store_id, first_name, last_name, email, address_id, activebool, create_date, last_update, active) FROM stdin;
	
2023-02-21 13:24:11.362 EET [656695] ERROR:  duplicate key value violates unique constraint "film_pkey"
2023-02-21 13:24:11.362 EET [656695] DETAIL:  Key (film_id)=(133) already exists.
2023-02-21 13:24:11.362 EET [656695] CONTEXT:  COPY film, line 1: "133	Chamber Italian	A Fateful Reflection of a Moose And a Husband who must Overcome a Monkey in Nige..."
2023-02-21 13:24:11.362 EET [656695] STATEMENT:  COPY public.film (film_id, title, description, release_year, language_id, rental_duration, rental_rate, length, replacement_cost, rating, last_update, special_features, fulltext) FROM stdin;
	
2023-02-21 13:24:11.365 EET [656695] ERROR:  duplicate key value violates unique constraint "film_actor_pkey"
2023-02-21 13:24:11.365 EET [656695] DETAIL:  Key (actor_id, film_id)=(1, 1) already exists.
2023-02-21 13:24:11.365 EET [656695] CONTEXT:  COPY film_actor, line 1
2023-02-21 13:24:11.365 EET [656695] STATEMENT:  COPY public.film_actor (actor_id, film_id, last_update) FROM stdin;
	
2023-02-21 13:24:11.368 EET [656695] ERROR:  duplicate key value violates unique constraint "film_category_pkey"
2023-02-21 13:24:11.368 EET [656695] DETAIL:  Key (film_id, category_id)=(1, 6) already exists.
2023-02-21 13:24:11.368 EET [656695] CONTEXT:  COPY film_category, line 1
2023-02-21 13:24:11.368 EET [656695] STATEMENT:  COPY public.film_category (film_id, category_id, last_update) FROM stdin;
	
2023-02-21 13:24:11.372 EET [656695] ERROR:  duplicate key value violates unique constraint "inventory_pkey"
2023-02-21 13:24:11.372 EET [656695] DETAIL:  Key (inventory_id)=(1) already exists.
2023-02-21 13:24:11.372 EET [656695] CONTEXT:  COPY inventory, line 1
2023-02-21 13:24:11.372 EET [656695] STATEMENT:  COPY public.inventory (inventory_id, film_id, store_id, last_update) FROM stdin;
	
2023-02-21 13:24:11.373 EET [656695] ERROR:  duplicate key value violates unique constraint "language_pkey"
2023-02-21 13:24:11.373 EET [656695] DETAIL:  Key (language_id)=(1) already exists.
2023-02-21 13:24:11.373 EET [656695] CONTEXT:  COPY language, line 1
2023-02-21 13:24:11.373 EET [656695] STATEMENT:  COPY public.language (language_id, name, last_update) FROM stdin;
	
2023-02-21 13:24:11.378 EET [656695] ERROR:  duplicate key value violates unique constraint "payment_pkey"
2023-02-21 13:24:11.378 EET [656695] DETAIL:  Key (payment_id)=(17503) already exists.
2023-02-21 13:24:11.378 EET [656695] CONTEXT:  COPY payment, line 1
2023-02-21 13:24:11.378 EET [656695] STATEMENT:  COPY public.payment (payment_id, customer_id, staff_id, rental_id, amount, payment_date) FROM stdin;
	
2023-02-21 13:24:11.382 EET [656695] ERROR:  duplicate key value violates unique constraint "rental_pkey"
2023-02-21 13:24:11.382 EET [656695] DETAIL:  Key (rental_id)=(2) already exists.
2023-02-21 13:24:11.382 EET [656695] CONTEXT:  COPY rental, line 1
2023-02-21 13:24:11.382 EET [656695] STATEMENT:  COPY public.rental (rental_id, rental_date, inventory_id, customer_id, return_date, staff_id, last_update) FROM stdin;
	
2023-02-21 13:24:11.383 EET [656695] ERROR:  duplicate key value violates unique constraint "staff_pkey"
2023-02-21 13:24:11.383 EET [656695] DETAIL:  Key (staff_id)=(1) already exists.
2023-02-21 13:24:11.383 EET [656695] CONTEXT:  COPY staff, line 1
2023-02-21 13:24:11.383 EET [656695] STATEMENT:  COPY public.staff (staff_id, first_name, last_name, address_id, email, store_id, active, username, password, last_update, picture) FROM stdin;
	
2023-02-21 13:24:11.383 EET [656695] ERROR:  duplicate key value violates unique constraint "store_pkey"
2023-02-21 13:24:11.383 EET [656695] DETAIL:  Key (store_id)=(1) already exists.
2023-02-21 13:24:11.383 EET [656695] CONTEXT:  COPY store, line 1
2023-02-21 13:24:11.383 EET [656695] STATEMENT:  COPY public.store (store_id, manager_staff_id, address_id, last_update) FROM stdin;
	
2023-02-21 13:24:11.429 EET [656695] ERROR:  multiple primary keys for table "actor" are not allowed
2023-02-21 13:24:11.429 EET [656695] STATEMENT:  ALTER TABLE ONLY public.actor
	    ADD CONSTRAINT actor_pkey PRIMARY KEY (actor_id);
	
	
	
2023-02-21 13:24:11.430 EET [656695] ERROR:  multiple primary keys for table "address" are not allowed
2023-02-21 13:24:11.430 EET [656695] STATEMENT:  ALTER TABLE ONLY public.address
	    ADD CONSTRAINT address_pkey PRIMARY KEY (address_id);
	
	
	
2023-02-21 13:24:11.430 EET [656695] ERROR:  multiple primary keys for table "category" are not allowed
2023-02-21 13:24:11.430 EET [656695] STATEMENT:  ALTER TABLE ONLY public.category
	    ADD CONSTRAINT category_pkey PRIMARY KEY (category_id);
	
	
	
2023-02-21 13:24:11.430 EET [656695] ERROR:  multiple primary keys for table "city" are not allowed
2023-02-21 13:24:11.430 EET [656695] STATEMENT:  ALTER TABLE ONLY public.city
	    ADD CONSTRAINT city_pkey PRIMARY KEY (city_id);
	
	
	
2023-02-21 13:24:11.430 EET [656695] ERROR:  multiple primary keys for table "country" are not allowed
2023-02-21 13:24:11.430 EET [656695] STATEMENT:  ALTER TABLE ONLY public.country
	    ADD CONSTRAINT country_pkey PRIMARY KEY (country_id);
	
	
	
2023-02-21 13:24:11.430 EET [656695] ERROR:  multiple primary keys for table "customer" are not allowed
2023-02-21 13:24:11.430 EET [656695] STATEMENT:  ALTER TABLE ONLY public.customer
	    ADD CONSTRAINT customer_pkey PRIMARY KEY (customer_id);
	
	
	
2023-02-21 13:24:11.430 EET [656695] ERROR:  multiple primary keys for table "film_actor" are not allowed
2023-02-21 13:24:11.430 EET [656695] STATEMENT:  ALTER TABLE ONLY public.film_actor
	    ADD CONSTRAINT film_actor_pkey PRIMARY KEY (actor_id, film_id);
	
	
	
2023-02-21 13:24:11.430 EET [656695] ERROR:  multiple primary keys for table "film_category" are not allowed
2023-02-21 13:24:11.430 EET [656695] STATEMENT:  ALTER TABLE ONLY public.film_category
	    ADD CONSTRAINT film_category_pkey PRIMARY KEY (film_id, category_id);
	
	
	
2023-02-21 13:24:11.431 EET [656695] ERROR:  multiple primary keys for table "film" are not allowed
2023-02-21 13:24:11.431 EET [656695] STATEMENT:  ALTER TABLE ONLY public.film
	    ADD CONSTRAINT film_pkey PRIMARY KEY (film_id);
	
	
	
2023-02-21 13:24:11.431 EET [656695] ERROR:  multiple primary keys for table "inventory" are not allowed
2023-02-21 13:24:11.431 EET [656695] STATEMENT:  ALTER TABLE ONLY public.inventory
	    ADD CONSTRAINT inventory_pkey PRIMARY KEY (inventory_id);
	
	
	
2023-02-21 13:24:11.431 EET [656695] ERROR:  multiple primary keys for table "language" are not allowed
2023-02-21 13:24:11.431 EET [656695] STATEMENT:  ALTER TABLE ONLY public.language
	    ADD CONSTRAINT language_pkey PRIMARY KEY (language_id);
	
	
	
2023-02-21 13:24:11.431 EET [656695] ERROR:  multiple primary keys for table "payment" are not allowed
2023-02-21 13:24:11.431 EET [656695] STATEMENT:  ALTER TABLE ONLY public.payment
	    ADD CONSTRAINT payment_pkey PRIMARY KEY (payment_id);
	
	
	
2023-02-21 13:24:11.431 EET [656695] ERROR:  multiple primary keys for table "rental" are not allowed
2023-02-21 13:24:11.431 EET [656695] STATEMENT:  ALTER TABLE ONLY public.rental
	    ADD CONSTRAINT rental_pkey PRIMARY KEY (rental_id);
	
	
	
2023-02-21 13:24:11.431 EET [656695] ERROR:  multiple primary keys for table "staff" are not allowed
2023-02-21 13:24:11.431 EET [656695] STATEMENT:  ALTER TABLE ONLY public.staff
	    ADD CONSTRAINT staff_pkey PRIMARY KEY (staff_id);
	
	
	
2023-02-21 13:24:11.431 EET [656695] ERROR:  multiple primary keys for table "store" are not allowed
2023-02-21 13:24:11.431 EET [656695] STATEMENT:  ALTER TABLE ONLY public.store
	    ADD CONSTRAINT store_pkey PRIMARY KEY (store_id);
	
	
	
2023-02-21 13:24:11.431 EET [656695] ERROR:  relation "film_fulltext_idx" already exists
2023-02-21 13:24:11.431 EET [656695] STATEMENT:  CREATE INDEX film_fulltext_idx ON public.film USING gist (fulltext);
	
	
	
2023-02-21 13:24:11.431 EET [656695] ERROR:  relation "idx_actor_last_name" already exists
2023-02-21 13:24:11.431 EET [656695] STATEMENT:  CREATE INDEX idx_actor_last_name ON public.actor USING btree (last_name);
	
	
	
2023-02-21 13:24:11.432 EET [656695] ERROR:  relation "idx_fk_address_id" already exists
2023-02-21 13:24:11.432 EET [656695] STATEMENT:  CREATE INDEX idx_fk_address_id ON public.customer USING btree (address_id);
	
	
	
2023-02-21 13:24:11.432 EET [656695] ERROR:  relation "idx_fk_city_id" already exists
2023-02-21 13:24:11.432 EET [656695] STATEMENT:  CREATE INDEX idx_fk_city_id ON public.address USING btree (city_id);
	
	
	
2023-02-21 13:24:11.432 EET [656695] ERROR:  relation "idx_fk_country_id" already exists
2023-02-21 13:24:11.432 EET [656695] STATEMENT:  CREATE INDEX idx_fk_country_id ON public.city USING btree (country_id);
	
	
	
2023-02-21 13:24:11.432 EET [656695] ERROR:  relation "idx_fk_customer_id" already exists
2023-02-21 13:24:11.432 EET [656695] STATEMENT:  CREATE INDEX idx_fk_customer_id ON public.payment USING btree (customer_id);
	
	
	
2023-02-21 13:24:11.432 EET [656695] ERROR:  relation "idx_fk_film_id" already exists
2023-02-21 13:24:11.432 EET [656695] STATEMENT:  CREATE INDEX idx_fk_film_id ON public.film_actor USING btree (film_id);
	
	
	
2023-02-21 13:24:11.432 EET [656695] ERROR:  relation "idx_fk_inventory_id" already exists
2023-02-21 13:24:11.432 EET [656695] STATEMENT:  CREATE INDEX idx_fk_inventory_id ON public.rental USING btree (inventory_id);
	
	
	
2023-02-21 13:24:11.432 EET [656695] ERROR:  relation "idx_fk_language_id" already exists
2023-02-21 13:24:11.432 EET [656695] STATEMENT:  CREATE INDEX idx_fk_language_id ON public.film USING btree (language_id);
	
	
	
2023-02-21 13:24:11.432 EET [656695] ERROR:  relation "idx_fk_rental_id" already exists
2023-02-21 13:24:11.432 EET [656695] STATEMENT:  CREATE INDEX idx_fk_rental_id ON public.payment USING btree (rental_id);
	
	
	
2023-02-21 13:24:11.432 EET [656695] ERROR:  relation "idx_fk_staff_id" already exists
2023-02-21 13:24:11.432 EET [656695] STATEMENT:  CREATE INDEX idx_fk_staff_id ON public.payment USING btree (staff_id);
	
	
	
2023-02-21 13:24:11.432 EET [656695] ERROR:  relation "idx_fk_store_id" already exists
2023-02-21 13:24:11.432 EET [656695] STATEMENT:  CREATE INDEX idx_fk_store_id ON public.customer USING btree (store_id);
	
	
	
2023-02-21 13:24:11.433 EET [656695] ERROR:  relation "idx_last_name" already exists
2023-02-21 13:24:11.433 EET [656695] STATEMENT:  CREATE INDEX idx_last_name ON public.customer USING btree (last_name);
	
	
	
2023-02-21 13:24:11.433 EET [656695] ERROR:  relation "idx_store_id_film_id" already exists
2023-02-21 13:24:11.433 EET [656695] STATEMENT:  CREATE INDEX idx_store_id_film_id ON public.inventory USING btree (store_id, film_id);
	
	
	
2023-02-21 13:24:11.433 EET [656695] ERROR:  relation "idx_title" already exists
2023-02-21 13:24:11.433 EET [656695] STATEMENT:  CREATE INDEX idx_title ON public.film USING btree (title);
	
	
	
2023-02-21 13:24:11.433 EET [656695] ERROR:  relation "idx_unq_manager_staff_id" already exists
2023-02-21 13:24:11.433 EET [656695] STATEMENT:  CREATE UNIQUE INDEX idx_unq_manager_staff_id ON public.store USING btree (manager_staff_id);
	
	
	
2023-02-21 13:24:11.433 EET [656695] ERROR:  relation "idx_unq_rental_rental_date_inventory_id_customer_id" already exists
2023-02-21 13:24:11.433 EET [656695] STATEMENT:  CREATE UNIQUE INDEX idx_unq_rental_rental_date_inventory_id_customer_id ON public.rental USING btree (rental_date, inventory_id, customer_id);
	
	
	
2023-02-21 13:24:11.433 EET [656695] ERROR:  trigger "film_fulltext_trigger" for relation "film" already exists
2023-02-21 13:24:11.433 EET [656695] STATEMENT:  CREATE TRIGGER film_fulltext_trigger BEFORE INSERT OR UPDATE ON public.film FOR EACH ROW EXECUTE PROCEDURE tsvector_update_trigger('fulltext', 'pg_catalog.english', 'title', 'description');
	
	
	
2023-02-21 13:24:11.433 EET [656695] ERROR:  trigger "last_updated" for relation "actor" already exists
2023-02-21 13:24:11.433 EET [656695] STATEMENT:  CREATE TRIGGER last_updated BEFORE UPDATE ON public.actor FOR EACH ROW EXECUTE PROCEDURE public.last_updated();
	
	
	
2023-02-21 13:24:11.433 EET [656695] ERROR:  trigger "last_updated" for relation "address" already exists
2023-02-21 13:24:11.433 EET [656695] STATEMENT:  CREATE TRIGGER last_updated BEFORE UPDATE ON public.address FOR EACH ROW EXECUTE PROCEDURE public.last_updated();
	
	
	
2023-02-21 13:24:11.434 EET [656695] ERROR:  trigger "last_updated" for relation "category" already exists
2023-02-21 13:24:11.434 EET [656695] STATEMENT:  CREATE TRIGGER last_updated BEFORE UPDATE ON public.category FOR EACH ROW EXECUTE PROCEDURE public.last_updated();
	
	
	
2023-02-21 13:24:11.434 EET [656695] ERROR:  trigger "last_updated" for relation "city" already exists
2023-02-21 13:24:11.434 EET [656695] STATEMENT:  CREATE TRIGGER last_updated BEFORE UPDATE ON public.city FOR EACH ROW EXECUTE PROCEDURE public.last_updated();
	
	
	
2023-02-21 13:24:11.434 EET [656695] ERROR:  trigger "last_updated" for relation "country" already exists
2023-02-21 13:24:11.434 EET [656695] STATEMENT:  CREATE TRIGGER last_updated BEFORE UPDATE ON public.country FOR EACH ROW EXECUTE PROCEDURE public.last_updated();
	
	
	
2023-02-21 13:24:11.434 EET [656695] ERROR:  trigger "last_updated" for relation "customer" already exists
2023-02-21 13:24:11.434 EET [656695] STATEMENT:  CREATE TRIGGER last_updated BEFORE UPDATE ON public.customer FOR EACH ROW EXECUTE PROCEDURE public.last_updated();
	
	
	
2023-02-21 13:24:11.434 EET [656695] ERROR:  trigger "last_updated" for relation "film" already exists
2023-02-21 13:24:11.434 EET [656695] STATEMENT:  CREATE TRIGGER last_updated BEFORE UPDATE ON public.film FOR EACH ROW EXECUTE PROCEDURE public.last_updated();
	
	
	
2023-02-21 13:24:11.434 EET [656695] ERROR:  trigger "last_updated" for relation "film_actor" already exists
2023-02-21 13:24:11.434 EET [656695] STATEMENT:  CREATE TRIGGER last_updated BEFORE UPDATE ON public.film_actor FOR EACH ROW EXECUTE PROCEDURE public.last_updated();
	
	
	
2023-02-21 13:24:11.434 EET [656695] ERROR:  trigger "last_updated" for relation "film_category" already exists
2023-02-21 13:24:11.434 EET [656695] STATEMENT:  CREATE TRIGGER last_updated BEFORE UPDATE ON public.film_category FOR EACH ROW EXECUTE PROCEDURE public.last_updated();
	
	
	
2023-02-21 13:24:11.434 EET [656695] ERROR:  trigger "last_updated" for relation "inventory" already exists
2023-02-21 13:24:11.434 EET [656695] STATEMENT:  CREATE TRIGGER last_updated BEFORE UPDATE ON public.inventory FOR EACH ROW EXECUTE PROCEDURE public.last_updated();
	
	
	
2023-02-21 13:24:11.434 EET [656695] ERROR:  trigger "last_updated" for relation "language" already exists
2023-02-21 13:24:11.434 EET [656695] STATEMENT:  CREATE TRIGGER last_updated BEFORE UPDATE ON public.language FOR EACH ROW EXECUTE PROCEDURE public.last_updated();
	
	
	
2023-02-21 13:24:11.434 EET [656695] ERROR:  trigger "last_updated" for relation "rental" already exists
2023-02-21 13:24:11.434 EET [656695] STATEMENT:  CREATE TRIGGER last_updated BEFORE UPDATE ON public.rental FOR EACH ROW EXECUTE PROCEDURE public.last_updated();
	
	
	
2023-02-21 13:24:11.434 EET [656695] ERROR:  trigger "last_updated" for relation "staff" already exists
2023-02-21 13:24:11.434 EET [656695] STATEMENT:  CREATE TRIGGER last_updated BEFORE UPDATE ON public.staff FOR EACH ROW EXECUTE PROCEDURE public.last_updated();
	
	
	
2023-02-21 13:24:11.434 EET [656695] ERROR:  trigger "last_updated" for relation "store" already exists
2023-02-21 13:24:11.434 EET [656695] STATEMENT:  CREATE TRIGGER last_updated BEFORE UPDATE ON public.store FOR EACH ROW EXECUTE PROCEDURE public.last_updated();
	
	
	
2023-02-21 13:24:11.435 EET [656695] ERROR:  constraint "customer_address_id_fkey" for relation "customer" already exists
2023-02-21 13:24:11.435 EET [656695] STATEMENT:  ALTER TABLE ONLY public.customer
	    ADD CONSTRAINT customer_address_id_fkey FOREIGN KEY (address_id) REFERENCES public.address(address_id) ON UPDATE CASCADE ON DELETE RESTRICT;
	
	
	
2023-02-21 13:24:11.435 EET [656695] ERROR:  constraint "film_actor_actor_id_fkey" for relation "film_actor" already exists
2023-02-21 13:24:11.435 EET [656695] STATEMENT:  ALTER TABLE ONLY public.film_actor
	    ADD CONSTRAINT film_actor_actor_id_fkey FOREIGN KEY (actor_id) REFERENCES public.actor(actor_id) ON UPDATE CASCADE ON DELETE RESTRICT;
	
	
	
2023-02-21 13:24:11.435 EET [656695] ERROR:  constraint "film_actor_film_id_fkey" for relation "film_actor" already exists
2023-02-21 13:24:11.435 EET [656695] STATEMENT:  ALTER TABLE ONLY public.film_actor
	    ADD CONSTRAINT film_actor_film_id_fkey FOREIGN KEY (film_id) REFERENCES public.film(film_id) ON UPDATE CASCADE ON DELETE RESTRICT;
	
	
	
2023-02-21 13:24:11.435 EET [656695] ERROR:  constraint "film_category_category_id_fkey" for relation "film_category" already exists
2023-02-21 13:24:11.435 EET [656695] STATEMENT:  ALTER TABLE ONLY public.film_category
	    ADD CONSTRAINT film_category_category_id_fkey FOREIGN KEY (category_id) REFERENCES public.category(category_id) ON UPDATE CASCADE ON DELETE RESTRICT;
	
	
	
2023-02-21 13:24:11.435 EET [656695] ERROR:  constraint "film_category_film_id_fkey" for relation "film_category" already exists
2023-02-21 13:24:11.435 EET [656695] STATEMENT:  ALTER TABLE ONLY public.film_category
	    ADD CONSTRAINT film_category_film_id_fkey FOREIGN KEY (film_id) REFERENCES public.film(film_id) ON UPDATE CASCADE ON DELETE RESTRICT;
	
	
	
2023-02-21 13:24:11.435 EET [656695] ERROR:  constraint "film_language_id_fkey" for relation "film" already exists
2023-02-21 13:24:11.435 EET [656695] STATEMENT:  ALTER TABLE ONLY public.film
	    ADD CONSTRAINT film_language_id_fkey FOREIGN KEY (language_id) REFERENCES public.language(language_id) ON UPDATE CASCADE ON DELETE RESTRICT;
	
	
	
2023-02-21 13:24:11.435 EET [656695] ERROR:  constraint "fk_address_city" for relation "address" already exists
2023-02-21 13:24:11.435 EET [656695] STATEMENT:  ALTER TABLE ONLY public.address
	    ADD CONSTRAINT fk_address_city FOREIGN KEY (city_id) REFERENCES public.city(city_id);
	
	
	
2023-02-21 13:24:11.435 EET [656695] ERROR:  constraint "fk_city" for relation "city" already exists
2023-02-21 13:24:11.435 EET [656695] STATEMENT:  ALTER TABLE ONLY public.city
	    ADD CONSTRAINT fk_city FOREIGN KEY (country_id) REFERENCES public.country(country_id);
	
	
	
2023-02-21 13:24:11.435 EET [656695] ERROR:  constraint "inventory_film_id_fkey" for relation "inventory" already exists
2023-02-21 13:24:11.435 EET [656695] STATEMENT:  ALTER TABLE ONLY public.inventory
	    ADD CONSTRAINT inventory_film_id_fkey FOREIGN KEY (film_id) REFERENCES public.film(film_id) ON UPDATE CASCADE ON DELETE RESTRICT;
	
	
	
2023-02-21 13:24:11.436 EET [656695] ERROR:  constraint "payment_customer_id_fkey" for relation "payment" already exists
2023-02-21 13:24:11.436 EET [656695] STATEMENT:  ALTER TABLE ONLY public.payment
	    ADD CONSTRAINT payment_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES public.customer(customer_id) ON UPDATE CASCADE ON DELETE RESTRICT;
	
	
	
2023-02-21 13:24:11.436 EET [656695] ERROR:  constraint "payment_rental_id_fkey" for relation "payment" already exists
2023-02-21 13:24:11.436 EET [656695] STATEMENT:  ALTER TABLE ONLY public.payment
	    ADD CONSTRAINT payment_rental_id_fkey FOREIGN KEY (rental_id) REFERENCES public.rental(rental_id) ON UPDATE CASCADE ON DELETE SET NULL;
	
	
	
2023-02-21 13:24:11.436 EET [656695] ERROR:  constraint "payment_staff_id_fkey" for relation "payment" already exists
2023-02-21 13:24:11.436 EET [656695] STATEMENT:  ALTER TABLE ONLY public.payment
	    ADD CONSTRAINT payment_staff_id_fkey FOREIGN KEY (staff_id) REFERENCES public.staff(staff_id) ON UPDATE CASCADE ON DELETE RESTRICT;
	
	
	
2023-02-21 13:24:11.436 EET [656695] ERROR:  constraint "rental_customer_id_fkey" for relation "rental" already exists
2023-02-21 13:24:11.436 EET [656695] STATEMENT:  ALTER TABLE ONLY public.rental
	    ADD CONSTRAINT rental_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES public.customer(customer_id) ON UPDATE CASCADE ON DELETE RESTRICT;
	
	
	
2023-02-21 13:24:11.436 EET [656695] ERROR:  constraint "rental_inventory_id_fkey" for relation "rental" already exists
2023-02-21 13:24:11.436 EET [656695] STATEMENT:  ALTER TABLE ONLY public.rental
	    ADD CONSTRAINT rental_inventory_id_fkey FOREIGN KEY (inventory_id) REFERENCES public.inventory(inventory_id) ON UPDATE CASCADE ON DELETE RESTRICT;
	
	
	
2023-02-21 13:24:11.436 EET [656695] ERROR:  constraint "rental_staff_id_key" for relation "rental" already exists
2023-02-21 13:24:11.436 EET [656695] STATEMENT:  ALTER TABLE ONLY public.rental
	    ADD CONSTRAINT rental_staff_id_key FOREIGN KEY (staff_id) REFERENCES public.staff(staff_id);
	
	
	
2023-02-21 13:24:11.436 EET [656695] ERROR:  constraint "staff_address_id_fkey" for relation "staff" already exists
2023-02-21 13:24:11.436 EET [656695] STATEMENT:  ALTER TABLE ONLY public.staff
	    ADD CONSTRAINT staff_address_id_fkey FOREIGN KEY (address_id) REFERENCES public.address(address_id) ON UPDATE CASCADE ON DELETE RESTRICT;
	
	
	
2023-02-21 13:24:11.436 EET [656695] ERROR:  constraint "store_address_id_fkey" for relation "store" already exists
2023-02-21 13:24:11.436 EET [656695] STATEMENT:  ALTER TABLE ONLY public.store
	    ADD CONSTRAINT store_address_id_fkey FOREIGN KEY (address_id) REFERENCES public.address(address_id) ON UPDATE CASCADE ON DELETE RESTRICT;
	
	
	
2023-02-21 13:24:11.436 EET [656695] ERROR:  constraint "store_manager_staff_id_fkey" for relation "store" already exists
2023-02-21 13:24:11.436 EET [656695] STATEMENT:  ALTER TABLE ONLY public.store
	    ADD CONSTRAINT store_manager_staff_id_fkey FOREIGN KEY (manager_staff_id) REFERENCES public.staff(staff_id) ON UPDATE CASCADE ON DELETE RESTRICT;
	
	
	
2023-02-21 13:24:11.617 EET [656709] ERROR:  type "mpaa_rating" already exists
2023-02-21 13:24:11.617 EET [656709] STATEMENT:  CREATE TYPE public.mpaa_rating AS ENUM (
	    'G',
	    'PG',
	    'PG-13',
	    'R',
	    'NC-17'
	);
	
	
	
2023-02-21 13:24:11.617 EET [656709] ERROR:  type "year" already exists
2023-02-21 13:24:11.617 EET [656709] STATEMENT:  CREATE DOMAIN public.year AS integer
		CONSTRAINT year_check CHECK (((VALUE >= 1901) AND (VALUE <= 2155)));
	
	
	
2023-02-21 13:24:11.617 EET [656709] ERROR:  function "_group_concat" already exists with same argument types
2023-02-21 13:24:11.617 EET [656709] STATEMENT:  CREATE FUNCTION public._group_concat(text, text) RETURNS text
	    LANGUAGE sql IMMUTABLE
	    AS $_$
	SELECT CASE
	  WHEN $2 IS NULL THEN $1
	  WHEN $1 IS NULL THEN $2
	  ELSE $1 || ', ' || $2
	END
	$_$;
	
	
	
2023-02-21 13:24:11.617 EET [656709] ERROR:  function "film_in_stock" already exists with same argument types
2023-02-21 13:24:11.617 EET [656709] STATEMENT:  CREATE FUNCTION public.film_in_stock(p_film_id integer, p_store_id integer, OUT p_film_count integer) RETURNS SETOF integer
	    LANGUAGE sql
	    AS $_$
	     SELECT inventory_id
	     FROM inventory
	     WHERE film_id = $1
	     AND store_id = $2
	     AND inventory_in_stock(inventory_id);
	$_$;
	
	
	
2023-02-21 13:24:11.618 EET [656709] ERROR:  function "film_not_in_stock" already exists with same argument types
2023-02-21 13:24:11.618 EET [656709] STATEMENT:  CREATE FUNCTION public.film_not_in_stock(p_film_id integer, p_store_id integer, OUT p_film_count integer) RETURNS SETOF integer
	    LANGUAGE sql
	    AS $_$
	    SELECT inventory_id
	    FROM inventory
	    WHERE film_id = $1
	    AND store_id = $2
	    AND NOT inventory_in_stock(inventory_id);
	$_$;
	
	
	
2023-02-21 13:24:11.618 EET [656709] ERROR:  function "get_customer_balance" already exists with same argument types
2023-02-21 13:24:11.618 EET [656709] STATEMENT:  CREATE FUNCTION public.get_customer_balance(p_customer_id integer, p_effective_date timestamp without time zone) RETURNS numeric
	    LANGUAGE plpgsql
	    AS $$
	       --#OK, WE NEED TO CALCULATE THE CURRENT BALANCE GIVEN A CUSTOMER_ID AND A DATE
	       --#THAT WE WANT THE BALANCE TO BE EFFECTIVE FOR. THE BALANCE IS:
	       --#   1) RENTAL FEES FOR ALL PREVIOUS RENTALS
	       --#   2) ONE DOLLAR FOR EVERY DAY THE PREVIOUS RENTALS ARE OVERDUE
	       --#   3) IF A FILM IS MORE THAN RENTAL_DURATION * 2 OVERDUE, CHARGE THE REPLACEMENT_COST
	       --#   4) SUBTRACT ALL PAYMENTS MADE BEFORE THE DATE SPECIFIED
	DECLARE
	    v_rentfees DECIMAL(5,2); --#FEES PAID TO RENT THE VIDEOS INITIALLY
	    v_overfees INTEGER;      --#LATE FEES FOR PRIOR RENTALS
	    v_payments DECIMAL(5,2); --#SUM OF PAYMENTS MADE PREVIOUSLY
	BEGIN
	    SELECT COALESCE(SUM(film.rental_rate),0) INTO v_rentfees
	    FROM film, inventory, rental
	    WHERE film.film_id = inventory.film_id
	      AND inventory.inventory_id = rental.inventory_id
	      AND rental.rental_date <= p_effective_date
	      AND rental.customer_id = p_customer_id;
	
	    SELECT COALESCE(SUM(IF((rental.return_date - rental.rental_date) > (film.rental_duration * '1 day'::interval),
	        ((rental.return_date - rental.rental_date) - (film.rental_duration * '1 day'::interval)),0)),0) INTO v_overfees
	    FROM rental, inventory, film
	    WHERE film.film_id = inventory.film_id
	      AND inventory.inventory_id = rental.inventory_id
	      AND rental.rental_date <= p_effective_date
	      AND rental.customer_id = p_customer_id;
	
	    SELECT COALESCE(SUM(payment.amount),0) INTO v_payments
	    FROM payment
	    WHERE payment.payment_date <= p_effective_date
	    AND payment.customer_id = p_customer_id;
	
	    RETURN v_rentfees + v_overfees - v_payments;
	END
	$$;
	
	
	
2023-02-21 13:24:11.618 EET [656709] ERROR:  function "inventory_held_by_customer" already exists with same argument types
2023-02-21 13:24:11.618 EET [656709] STATEMENT:  CREATE FUNCTION public.inventory_held_by_customer(p_inventory_id integer) RETURNS integer
	    LANGUAGE plpgsql
	    AS $$
	DECLARE
	    v_customer_id INTEGER;
	BEGIN
	
	  SELECT customer_id INTO v_customer_id
	  FROM rental
	  WHERE return_date IS NULL
	  AND inventory_id = p_inventory_id;
	
	  RETURN v_customer_id;
	END $$;
	
	
	
2023-02-21 13:24:11.618 EET [656709] ERROR:  function "inventory_in_stock" already exists with same argument types
2023-02-21 13:24:11.618 EET [656709] STATEMENT:  CREATE FUNCTION public.inventory_in_stock(p_inventory_id integer) RETURNS boolean
	    LANGUAGE plpgsql
	    AS $$
	DECLARE
	    v_rentals INTEGER;
	    v_out     INTEGER;
	BEGIN
	    -- AN ITEM IS IN-STOCK IF THERE ARE EITHER NO ROWS IN THE rental TABLE
	    -- FOR THE ITEM OR ALL ROWS HAVE return_date POPULATED
	
	    SELECT count(*) INTO v_rentals
	    FROM rental
	    WHERE inventory_id = p_inventory_id;
	
	    IF v_rentals = 0 THEN
	      RETURN TRUE;
	    END IF;
	
	    SELECT COUNT(rental_id) INTO v_out
	    FROM inventory LEFT JOIN rental USING(inventory_id)
	    WHERE inventory.inventory_id = p_inventory_id
	    AND rental.return_date IS NULL;
	
	    IF v_out > 0 THEN
	      RETURN FALSE;
	    ELSE
	      RETURN TRUE;
	    END IF;
	END $$;
	
	
	
2023-02-21 13:24:11.618 EET [656709] ERROR:  function "last_day" already exists with same argument types
2023-02-21 13:24:11.618 EET [656709] STATEMENT:  CREATE FUNCTION public.last_day(timestamp without time zone) RETURNS date
	    LANGUAGE sql IMMUTABLE STRICT
	    AS $_$
	  SELECT CASE
	    WHEN EXTRACT(MONTH FROM $1) = 12 THEN
	      (((EXTRACT(YEAR FROM $1) + 1) operator(pg_catalog.||) '-01-01')::date - INTERVAL '1 day')::date
	    ELSE
	      ((EXTRACT(YEAR FROM $1) operator(pg_catalog.||) '-' operator(pg_catalog.||) (EXTRACT(MONTH FROM $1) + 1) operator(pg_catalog.||) '-01')::date - INTERVAL '1 day')::date
	    END
	$_$;
	
	
	
2023-02-21 13:24:11.619 EET [656709] ERROR:  function "last_updated" already exists with same argument types
2023-02-21 13:24:11.619 EET [656709] STATEMENT:  CREATE FUNCTION public.last_updated() RETURNS trigger
	    LANGUAGE plpgsql
	    AS $$
	BEGIN
	    NEW.last_update = CURRENT_TIMESTAMP;
	    RETURN NEW;
	END $$;
	
	
	
2023-02-21 13:24:11.619 EET [656709] ERROR:  relation "customer_customer_id_seq" already exists
2023-02-21 13:24:11.619 EET [656709] STATEMENT:  CREATE SEQUENCE public.customer_customer_id_seq
	    START WITH 1
	    INCREMENT BY 1
	    NO MINVALUE
	    NO MAXVALUE
	    CACHE 1;
	
	
	
2023-02-21 13:24:11.623 EET [656709] ERROR:  relation "customer" already exists
2023-02-21 13:24:11.623 EET [656709] STATEMENT:  CREATE TABLE public.customer (
	    customer_id integer DEFAULT nextval('public.customer_customer_id_seq'::regclass) NOT NULL,
	    store_id smallint NOT NULL,
	    first_name character varying(45) NOT NULL,
	    last_name character varying(45) NOT NULL,
	    email character varying(50),
	    address_id smallint NOT NULL,
	    activebool boolean DEFAULT true NOT NULL,
	    create_date date DEFAULT ('now'::text)::date NOT NULL,
	    last_update timestamp without time zone DEFAULT now(),
	    active integer
	);
	
	
	
2023-02-21 13:24:11.627 EET [656709] ERROR:  function "rewards_report" already exists with same argument types
2023-02-21 13:24:11.627 EET [656709] STATEMENT:  CREATE FUNCTION public.rewards_report(min_monthly_purchases integer, min_dollar_amount_purchased numeric) RETURNS SETOF public.customer
	    LANGUAGE plpgsql SECURITY DEFINER
	    AS $_$
	DECLARE
	    last_month_start DATE;
	    last_month_end DATE;
	rr RECORD;
	tmpSQL TEXT;
	BEGIN
	
	    /* Some sanity checks... */
	    IF min_monthly_purchases = 0 THEN
	        RAISE EXCEPTION 'Minimum monthly purchases parameter must be > 0';
	    END IF;
	    IF min_dollar_amount_purchased = 0.00 THEN
	        RAISE EXCEPTION 'Minimum monthly dollar amount purchased parameter must be > $0.00';
	    END IF;
	
	    last_month_start := CURRENT_DATE - '3 month'::interval;
	    last_month_start := to_date((extract(YEAR FROM last_month_start) || '-' || extract(MONTH FROM last_month_start) || '-01'),'YYYY-MM-DD');
	    last_month_end := LAST_DAY(last_month_start);
	
	    /*
	    Create a temporary storage area for Customer IDs.
	    */
	    CREATE TEMPORARY TABLE tmpCustomer (customer_id INTEGER NOT NULL PRIMARY KEY);
	
	    /*
	    Find all customers meeting the monthly purchase requirements
	    */
	
	    tmpSQL := 'INSERT INTO tmpCustomer (customer_id)
	        SELECT p.customer_id
	        FROM payment AS p
	        WHERE DATE(p.payment_date) BETWEEN '||quote_literal(last_month_start) ||' AND '|| quote_literal(last_month_end) || '
	        GROUP BY customer_id
	        HAVING SUM(p.amount) > '|| min_dollar_amount_purchased || '
	        AND COUNT(customer_id) > ' ||min_monthly_purchases ;
	
	    EXECUTE tmpSQL;
	
	    /*
	    Output ALL customer information of matching rewardees.
	    Customize output as needed.
	    */
	    FOR rr IN EXECUTE 'SELECT c.* FROM tmpCustomer AS t INNER JOIN customer AS c ON t.customer_id = c.customer_id' LOOP
	        RETURN NEXT rr;
	    END LOOP;
	
	    /* Clean up */
	    tmpSQL := 'DROP TABLE tmpCustomer';
	    EXECUTE tmpSQL;
	
	RETURN;
	END
	$_$;
	
	
	
2023-02-21 13:24:11.627 EET [656709] ERROR:  function "group_concat" already exists with same argument types
2023-02-21 13:24:11.627 EET [656709] STATEMENT:  CREATE AGGREGATE public.group_concat(text) (
	    SFUNC = public._group_concat,
	    STYPE = text
	);
	
	
	
2023-02-21 13:24:11.628 EET [656709] ERROR:  relation "actor_actor_id_seq" already exists
2023-02-21 13:24:11.628 EET [656709] STATEMENT:  CREATE SEQUENCE public.actor_actor_id_seq
	    START WITH 1
	    INCREMENT BY 1
	    NO MINVALUE
	    NO MAXVALUE
	    CACHE 1;
	
	
	
2023-02-21 13:24:11.631 EET [656709] ERROR:  relation "actor" already exists
2023-02-21 13:24:11.631 EET [656709] STATEMENT:  CREATE TABLE public.actor (
	    actor_id integer DEFAULT nextval('public.actor_actor_id_seq'::regclass) NOT NULL,
	    first_name character varying(45) NOT NULL,
	    last_name character varying(45) NOT NULL,
	    last_update timestamp without time zone DEFAULT now() NOT NULL
	);
	
	
	
2023-02-21 13:24:11.635 EET [656709] ERROR:  relation "category_category_id_seq" already exists
2023-02-21 13:24:11.635 EET [656709] STATEMENT:  CREATE SEQUENCE public.category_category_id_seq
	    START WITH 1
	    INCREMENT BY 1
	    NO MINVALUE
	    NO MAXVALUE
	    CACHE 1;
	
	
	
2023-02-21 13:24:11.639 EET [656709] ERROR:  relation "category" already exists
2023-02-21 13:24:11.639 EET [656709] STATEMENT:  CREATE TABLE public.category (
	    category_id integer DEFAULT nextval('public.category_category_id_seq'::regclass) NOT NULL,
	    name character varying(25) NOT NULL,
	    last_update timestamp without time zone DEFAULT now() NOT NULL
	);
	
	
	
2023-02-21 13:24:11.643 EET [656709] ERROR:  relation "film_film_id_seq" already exists
2023-02-21 13:24:11.643 EET [656709] STATEMENT:  CREATE SEQUENCE public.film_film_id_seq
	    START WITH 1
	    INCREMENT BY 1
	    NO MINVALUE
	    NO MAXVALUE
	    CACHE 1;
	
	
	
2023-02-21 13:24:11.647 EET [656709] ERROR:  relation "film" already exists
2023-02-21 13:24:11.647 EET [656709] STATEMENT:  CREATE TABLE public.film (
	    film_id integer DEFAULT nextval('public.film_film_id_seq'::regclass) NOT NULL,
	    title character varying(255) NOT NULL,
	    description text,
	    release_year public.year,
	    language_id smallint NOT NULL,
	    rental_duration smallint DEFAULT 3 NOT NULL,
	    rental_rate numeric(4,2) DEFAULT 4.99 NOT NULL,
	    length smallint,
	    replacement_cost numeric(5,2) DEFAULT 19.99 NOT NULL,
	    rating public.mpaa_rating DEFAULT 'G'::public.mpaa_rating,
	    last_update timestamp without time zone DEFAULT now() NOT NULL,
	    special_features text[],
	    fulltext tsvector NOT NULL
	);
	
	
	
2023-02-21 13:24:11.651 EET [656709] ERROR:  relation "film_actor" already exists
2023-02-21 13:24:11.651 EET [656709] STATEMENT:  CREATE TABLE public.film_actor (
	    actor_id smallint NOT NULL,
	    film_id smallint NOT NULL,
	    last_update timestamp without time zone DEFAULT now() NOT NULL
	);
	
	
	
2023-02-21 13:24:11.654 EET [656709] ERROR:  relation "film_category" already exists
2023-02-21 13:24:11.654 EET [656709] STATEMENT:  CREATE TABLE public.film_category (
	    film_id smallint NOT NULL,
	    category_id smallint NOT NULL,
	    last_update timestamp without time zone DEFAULT now() NOT NULL
	);
	
	
	
2023-02-21 13:24:11.659 EET [656709] ERROR:  relation "actor_info" already exists
2023-02-21 13:24:11.659 EET [656709] STATEMENT:  CREATE VIEW public.actor_info AS
	 SELECT a.actor_id,
	    a.first_name,
	    a.last_name,
	    public.group_concat(DISTINCT (((c.name)::text || ': '::text) || ( SELECT public.group_concat((f.title)::text) AS group_concat
	           FROM ((public.film f
	             JOIN public.film_category fc_1 ON ((f.film_id = fc_1.film_id)))
	             JOIN public.film_actor fa_1 ON ((f.film_id = fa_1.film_id)))
	          WHERE ((fc_1.category_id = c.category_id) AND (fa_1.actor_id = a.actor_id))
	          GROUP BY fa_1.actor_id))) AS film_info
	   FROM (((public.actor a
	     LEFT JOIN public.film_actor fa ON ((a.actor_id = fa.actor_id)))
	     LEFT JOIN public.film_category fc ON ((fa.film_id = fc.film_id)))
	     LEFT JOIN public.category c ON ((fc.category_id = c.category_id)))
	  GROUP BY a.actor_id, a.first_name, a.last_name;
	
	
	
2023-02-21 13:24:11.663 EET [656709] ERROR:  relation "address_address_id_seq" already exists
2023-02-21 13:24:11.663 EET [656709] STATEMENT:  CREATE SEQUENCE public.address_address_id_seq
	    START WITH 1
	    INCREMENT BY 1
	    NO MINVALUE
	    NO MAXVALUE
	    CACHE 1;
	
	
	
2023-02-21 13:24:11.666 EET [656709] ERROR:  relation "address" already exists
2023-02-21 13:24:11.666 EET [656709] STATEMENT:  CREATE TABLE public.address (
	    address_id integer DEFAULT nextval('public.address_address_id_seq'::regclass) NOT NULL,
	    address character varying(50) NOT NULL,
	    address2 character varying(50),
	    district character varying(20) NOT NULL,
	    city_id smallint NOT NULL,
	    postal_code character varying(10),
	    phone character varying(20) NOT NULL,
	    last_update timestamp without time zone DEFAULT now() NOT NULL
	);
	
	
	
2023-02-21 13:24:11.670 EET [656709] ERROR:  relation "city_city_id_seq" already exists
2023-02-21 13:24:11.670 EET [656709] STATEMENT:  CREATE SEQUENCE public.city_city_id_seq
	    START WITH 1
	    INCREMENT BY 1
	    NO MINVALUE
	    NO MAXVALUE
	    CACHE 1;
	
	
	
2023-02-21 13:24:11.674 EET [656709] ERROR:  relation "city" already exists
2023-02-21 13:24:11.674 EET [656709] STATEMENT:  CREATE TABLE public.city (
	    city_id integer DEFAULT nextval('public.city_city_id_seq'::regclass) NOT NULL,
	    city character varying(50) NOT NULL,
	    country_id smallint NOT NULL,
	    last_update timestamp without time zone DEFAULT now() NOT NULL
	);
	
	
	
2023-02-21 13:24:11.678 EET [656709] ERROR:  relation "country_country_id_seq" already exists
2023-02-21 13:24:11.678 EET [656709] STATEMENT:  CREATE SEQUENCE public.country_country_id_seq
	    START WITH 1
	    INCREMENT BY 1
	    NO MINVALUE
	    NO MAXVALUE
	    CACHE 1;
	
	
	
2023-02-21 13:24:11.681 EET [656709] ERROR:  relation "country" already exists
2023-02-21 13:24:11.681 EET [656709] STATEMENT:  CREATE TABLE public.country (
	    country_id integer DEFAULT nextval('public.country_country_id_seq'::regclass) NOT NULL,
	    country character varying(50) NOT NULL,
	    last_update timestamp without time zone DEFAULT now() NOT NULL
	);
	
	
	
2023-02-21 13:24:11.685 EET [656709] ERROR:  relation "customer_list" already exists
2023-02-21 13:24:11.685 EET [656709] STATEMENT:  CREATE VIEW public.customer_list AS
	 SELECT cu.customer_id AS id,
	    (((cu.first_name)::text || ' '::text) || (cu.last_name)::text) AS name,
	    a.address,
	    a.postal_code AS "zip code",
	    a.phone,
	    city.city,
	    country.country,
	        CASE
	            WHEN cu.activebool THEN 'active'::text
	            ELSE ''::text
	        END AS notes,
	    cu.store_id AS sid
	   FROM (((public.customer cu
	     JOIN public.address a ON ((cu.address_id = a.address_id)))
	     JOIN public.city ON ((a.city_id = city.city_id)))
	     JOIN public.country ON ((city.country_id = country.country_id)));
	
	
	
2023-02-21 13:24:11.690 EET [656709] ERROR:  relation "film_list" already exists
2023-02-21 13:24:11.690 EET [656709] STATEMENT:  CREATE VIEW public.film_list AS
	 SELECT film.film_id AS fid,
	    film.title,
	    film.description,
	    category.name AS category,
	    film.rental_rate AS price,
	    film.length,
	    film.rating,
	    public.group_concat((((actor.first_name)::text || ' '::text) || (actor.last_name)::text)) AS actors
	   FROM ((((public.category
	     LEFT JOIN public.film_category ON ((category.category_id = film_category.category_id)))
	     LEFT JOIN public.film ON ((film_category.film_id = film.film_id)))
	     JOIN public.film_actor ON ((film.film_id = film_actor.film_id)))
	     JOIN public.actor ON ((film_actor.actor_id = actor.actor_id)))
	  GROUP BY film.film_id, film.title, film.description, category.name, film.rental_rate, film.length, film.rating;
	
	
	
2023-02-21 13:24:11.694 EET [656709] ERROR:  relation "inventory_inventory_id_seq" already exists
2023-02-21 13:24:11.694 EET [656709] STATEMENT:  CREATE SEQUENCE public.inventory_inventory_id_seq
	    START WITH 1
	    INCREMENT BY 1
	    NO MINVALUE
	    NO MAXVALUE
	    CACHE 1;
	
	
	
2023-02-21 13:24:11.698 EET [656709] ERROR:  relation "inventory" already exists
2023-02-21 13:24:11.698 EET [656709] STATEMENT:  CREATE TABLE public.inventory (
	    inventory_id integer DEFAULT nextval('public.inventory_inventory_id_seq'::regclass) NOT NULL,
	    film_id smallint NOT NULL,
	    store_id smallint NOT NULL,
	    last_update timestamp without time zone DEFAULT now() NOT NULL
	);
	
	
	
2023-02-21 13:24:11.702 EET [656709] ERROR:  relation "language_language_id_seq" already exists
2023-02-21 13:24:11.702 EET [656709] STATEMENT:  CREATE SEQUENCE public.language_language_id_seq
	    START WITH 1
	    INCREMENT BY 1
	    NO MINVALUE
	    NO MAXVALUE
	    CACHE 1;
	
	
	
2023-02-21 13:24:11.706 EET [656709] ERROR:  relation "language" already exists
2023-02-21 13:24:11.706 EET [656709] STATEMENT:  CREATE TABLE public.language (
	    language_id integer DEFAULT nextval('public.language_language_id_seq'::regclass) NOT NULL,
	    name character(20) NOT NULL,
	    last_update timestamp without time zone DEFAULT now() NOT NULL
	);
	
	
	
2023-02-21 13:24:11.711 EET [656709] ERROR:  relation "nicer_but_slower_film_list" already exists
2023-02-21 13:24:11.711 EET [656709] STATEMENT:  CREATE VIEW public.nicer_but_slower_film_list AS
	 SELECT film.film_id AS fid,
	    film.title,
	    film.description,
	    category.name AS category,
	    film.rental_rate AS price,
	    film.length,
	    film.rating,
	    public.group_concat((((upper("substring"((actor.first_name)::text, 1, 1)) || lower("substring"((actor.first_name)::text, 2))) || upper("substring"((actor.last_name)::text, 1, 1))) || lower("substring"((actor.last_name)::text, 2)))) AS actors
	   FROM ((((public.category
	     LEFT JOIN public.film_category ON ((category.category_id = film_category.category_id)))
	     LEFT JOIN public.film ON ((film_category.film_id = film.film_id)))
	     JOIN public.film_actor ON ((film.film_id = film_actor.film_id)))
	     JOIN public.actor ON ((film_actor.actor_id = actor.actor_id)))
	  GROUP BY film.film_id, film.title, film.description, category.name, film.rental_rate, film.length, film.rating;
	
	
	
2023-02-21 13:24:11.715 EET [656709] ERROR:  relation "payment_payment_id_seq" already exists
2023-02-21 13:24:11.715 EET [656709] STATEMENT:  CREATE SEQUENCE public.payment_payment_id_seq
	    START WITH 1
	    INCREMENT BY 1
	    NO MINVALUE
	    NO MAXVALUE
	    CACHE 1;
	
	
	
2023-02-21 13:24:11.720 EET [656709] ERROR:  relation "payment" already exists
2023-02-21 13:24:11.720 EET [656709] STATEMENT:  CREATE TABLE public.payment (
	    payment_id integer DEFAULT nextval('public.payment_payment_id_seq'::regclass) NOT NULL,
	    customer_id smallint NOT NULL,
	    staff_id smallint NOT NULL,
	    rental_id integer NOT NULL,
	    amount numeric(5,2) NOT NULL,
	    payment_date timestamp without time zone NOT NULL
	);
	
	
	
2023-02-21 13:24:11.724 EET [656709] ERROR:  relation "rental_rental_id_seq" already exists
2023-02-21 13:24:11.724 EET [656709] STATEMENT:  CREATE SEQUENCE public.rental_rental_id_seq
	    START WITH 1
	    INCREMENT BY 1
	    NO MINVALUE
	    NO MAXVALUE
	    CACHE 1;
	
	
	
2023-02-21 13:24:11.728 EET [656709] ERROR:  relation "rental" already exists
2023-02-21 13:24:11.728 EET [656709] STATEMENT:  CREATE TABLE public.rental (
	    rental_id integer DEFAULT nextval('public.rental_rental_id_seq'::regclass) NOT NULL,
	    rental_date timestamp without time zone NOT NULL,
	    inventory_id integer NOT NULL,
	    customer_id smallint NOT NULL,
	    return_date timestamp without time zone,
	    staff_id smallint NOT NULL,
	    last_update timestamp without time zone DEFAULT now() NOT NULL
	);
	
	
	
2023-02-21 13:24:11.733 EET [656709] ERROR:  relation "sales_by_film_category" already exists
2023-02-21 13:24:11.733 EET [656709] STATEMENT:  CREATE VIEW public.sales_by_film_category AS
	 SELECT c.name AS category,
	    sum(p.amount) AS total_sales
	   FROM (((((public.payment p
	     JOIN public.rental r ON ((p.rental_id = r.rental_id)))
	     JOIN public.inventory i ON ((r.inventory_id = i.inventory_id)))
	     JOIN public.film f ON ((i.film_id = f.film_id)))
	     JOIN public.film_category fc ON ((f.film_id = fc.film_id)))
	     JOIN public.category c ON ((fc.category_id = c.category_id)))
	  GROUP BY c.name
	  ORDER BY (sum(p.amount)) DESC;
	
	
	
2023-02-21 13:24:11.737 EET [656709] ERROR:  relation "staff_staff_id_seq" already exists
2023-02-21 13:24:11.737 EET [656709] STATEMENT:  CREATE SEQUENCE public.staff_staff_id_seq
	    START WITH 1
	    INCREMENT BY 1
	    NO MINVALUE
	    NO MAXVALUE
	    CACHE 1;
	
	
	
2023-02-21 13:24:11.741 EET [656709] ERROR:  relation "staff" already exists
2023-02-21 13:24:11.741 EET [656709] STATEMENT:  CREATE TABLE public.staff (
	    staff_id integer DEFAULT nextval('public.staff_staff_id_seq'::regclass) NOT NULL,
	    first_name character varying(45) NOT NULL,
	    last_name character varying(45) NOT NULL,
	    address_id smallint NOT NULL,
	    email character varying(50),
	    store_id smallint NOT NULL,
	    active boolean DEFAULT true NOT NULL,
	    username character varying(16) NOT NULL,
	    password character varying(40),
	    last_update timestamp without time zone DEFAULT now() NOT NULL,
	    picture bytea
	);
	
	
	
2023-02-21 13:24:11.745 EET [656709] ERROR:  relation "store_store_id_seq" already exists
2023-02-21 13:24:11.745 EET [656709] STATEMENT:  CREATE SEQUENCE public.store_store_id_seq
	    START WITH 1
	    INCREMENT BY 1
	    NO MINVALUE
	    NO MAXVALUE
	    CACHE 1;
	
	
	
2023-02-21 13:24:11.749 EET [656709] ERROR:  relation "store" already exists
2023-02-21 13:24:11.749 EET [656709] STATEMENT:  CREATE TABLE public.store (
	    store_id integer DEFAULT nextval('public.store_store_id_seq'::regclass) NOT NULL,
	    manager_staff_id smallint NOT NULL,
	    address_id smallint NOT NULL,
	    last_update timestamp without time zone DEFAULT now() NOT NULL
	);
	
	
	
2023-02-21 13:24:11.754 EET [656709] ERROR:  relation "sales_by_store" already exists
2023-02-21 13:24:11.754 EET [656709] STATEMENT:  CREATE VIEW public.sales_by_store AS
	 SELECT (((c.city)::text || ','::text) || (cy.country)::text) AS store,
	    (((m.first_name)::text || ' '::text) || (m.last_name)::text) AS manager,
	    sum(p.amount) AS total_sales
	   FROM (((((((public.payment p
	     JOIN public.rental r ON ((p.rental_id = r.rental_id)))
	     JOIN public.inventory i ON ((r.inventory_id = i.inventory_id)))
	     JOIN public.store s ON ((i.store_id = s.store_id)))
	     JOIN public.address a ON ((s.address_id = a.address_id)))
	     JOIN public.city c ON ((a.city_id = c.city_id)))
	     JOIN public.country cy ON ((c.country_id = cy.country_id)))
	     JOIN public.staff m ON ((s.manager_staff_id = m.staff_id)))
	  GROUP BY cy.country, c.city, s.store_id, m.first_name, m.last_name
	  ORDER BY cy.country, c.city;
	
	
	
2023-02-21 13:24:11.760 EET [656709] ERROR:  relation "staff_list" already exists
2023-02-21 13:24:11.760 EET [656709] STATEMENT:  CREATE VIEW public.staff_list AS
	 SELECT s.staff_id AS id,
	    (((s.first_name)::text || ' '::text) || (s.last_name)::text) AS name,
	    a.address,
	    a.postal_code AS "zip code",
	    a.phone,
	    city.city,
	    country.country,
	    s.store_id AS sid
	   FROM (((public.staff s
	     JOIN public.address a ON ((s.address_id = a.address_id)))
	     JOIN public.city ON ((a.city_id = city.city_id)))
	     JOIN public.country ON ((city.country_id = country.country_id)));
	
	
	
2023-02-21 13:24:11.767 EET [656709] ERROR:  duplicate key value violates unique constraint "actor_pkey"
2023-02-21 13:24:11.767 EET [656709] DETAIL:  Key (actor_id)=(1) already exists.
2023-02-21 13:24:11.767 EET [656709] CONTEXT:  COPY actor, line 1
2023-02-21 13:24:11.767 EET [656709] STATEMENT:  COPY public.actor (actor_id, first_name, last_name, last_update) FROM stdin;
	
2023-02-21 13:24:11.772 EET [656709] ERROR:  duplicate key value violates unique constraint "address_pkey"
2023-02-21 13:24:11.772 EET [656709] DETAIL:  Key (address_id)=(1) already exists.
2023-02-21 13:24:11.772 EET [656709] CONTEXT:  COPY address, line 1
2023-02-21 13:24:11.772 EET [656709] STATEMENT:  COPY public.address (address_id, address, address2, district, city_id, postal_code, phone, last_update) FROM stdin;
	
2023-02-21 13:24:11.773 EET [656709] ERROR:  duplicate key value violates unique constraint "category_pkey"
2023-02-21 13:24:11.773 EET [656709] DETAIL:  Key (category_id)=(1) already exists.
2023-02-21 13:24:11.773 EET [656709] CONTEXT:  COPY category, line 1
2023-02-21 13:24:11.773 EET [656709] STATEMENT:  COPY public.category (category_id, name, last_update) FROM stdin;
	
2023-02-21 13:24:11.777 EET [656709] ERROR:  duplicate key value violates unique constraint "city_pkey"
2023-02-21 13:24:11.777 EET [656709] DETAIL:  Key (city_id)=(1) already exists.
2023-02-21 13:24:11.777 EET [656709] CONTEXT:  COPY city, line 1
2023-02-21 13:24:11.777 EET [656709] STATEMENT:  COPY public.city (city_id, city, country_id, last_update) FROM stdin;
	
2023-02-21 13:24:11.778 EET [656709] ERROR:  duplicate key value violates unique constraint "country_pkey"
2023-02-21 13:24:11.778 EET [656709] DETAIL:  Key (country_id)=(1) already exists.
2023-02-21 13:24:11.778 EET [656709] CONTEXT:  COPY country, line 1
2023-02-21 13:24:11.778 EET [656709] STATEMENT:  COPY public.country (country_id, country, last_update) FROM stdin;
	
2023-02-21 13:24:11.784 EET [656709] ERROR:  duplicate key value violates unique constraint "customer_pkey"
2023-02-21 13:24:11.784 EET [656709] DETAIL:  Key (customer_id)=(524) already exists.
2023-02-21 13:24:11.784 EET [656709] CONTEXT:  COPY customer, line 1
2023-02-21 13:24:11.784 EET [656709] STATEMENT:  COPY public.customer (customer_id, store_id, first_name, last_name, email, address_id, activebool, create_date, last_update, active) FROM stdin;
	
2023-02-21 13:24:11.788 EET [656709] ERROR:  duplicate key value violates unique constraint "film_pkey"
2023-02-21 13:24:11.788 EET [656709] DETAIL:  Key (film_id)=(133) already exists.
2023-02-21 13:24:11.788 EET [656709] CONTEXT:  COPY film, line 1: "133	Chamber Italian	A Fateful Reflection of a Moose And a Husband who must Overcome a Monkey in Nige..."
2023-02-21 13:24:11.788 EET [656709] STATEMENT:  COPY public.film (film_id, title, description, release_year, language_id, rental_duration, rental_rate, length, replacement_cost, rating, last_update, special_features, fulltext) FROM stdin;
	
2023-02-21 13:24:11.795 EET [656709] ERROR:  duplicate key value violates unique constraint "film_actor_pkey"
2023-02-21 13:24:11.795 EET [656709] DETAIL:  Key (actor_id, film_id)=(1, 1) already exists.
2023-02-21 13:24:11.795 EET [656709] CONTEXT:  COPY film_actor, line 1
2023-02-21 13:24:11.795 EET [656709] STATEMENT:  COPY public.film_actor (actor_id, film_id, last_update) FROM stdin;
	
2023-02-21 13:24:11.803 EET [656709] ERROR:  duplicate key value violates unique constraint "film_category_pkey"
2023-02-21 13:24:11.803 EET [656709] DETAIL:  Key (film_id, category_id)=(1, 6) already exists.
2023-02-21 13:24:11.803 EET [656709] CONTEXT:  COPY film_category, line 1
2023-02-21 13:24:11.803 EET [656709] STATEMENT:  COPY public.film_category (film_id, category_id, last_update) FROM stdin;
	
2023-02-21 13:24:11.807 EET [656709] ERROR:  duplicate key value violates unique constraint "inventory_pkey"
2023-02-21 13:24:11.807 EET [656709] DETAIL:  Key (inventory_id)=(1) already exists.
2023-02-21 13:24:11.807 EET [656709] CONTEXT:  COPY inventory, line 1
2023-02-21 13:24:11.807 EET [656709] STATEMENT:  COPY public.inventory (inventory_id, film_id, store_id, last_update) FROM stdin;
	
2023-02-21 13:24:11.807 EET [656709] ERROR:  duplicate key value violates unique constraint "language_pkey"
2023-02-21 13:24:11.807 EET [656709] DETAIL:  Key (language_id)=(1) already exists.
2023-02-21 13:24:11.807 EET [656709] CONTEXT:  COPY language, line 1
2023-02-21 13:24:11.807 EET [656709] STATEMENT:  COPY public.language (language_id, name, last_update) FROM stdin;
	
2023-02-21 13:24:11.811 EET [656709] ERROR:  duplicate key value violates unique constraint "payment_pkey"
2023-02-21 13:24:11.811 EET [656709] DETAIL:  Key (payment_id)=(17503) already exists.
2023-02-21 13:24:11.811 EET [656709] CONTEXT:  COPY payment, line 1
2023-02-21 13:24:11.811 EET [656709] STATEMENT:  COPY public.payment (payment_id, customer_id, staff_id, rental_id, amount, payment_date) FROM stdin;
	
2023-02-21 13:24:11.816 EET [656709] ERROR:  duplicate key value violates unique constraint "rental_pkey"
2023-02-21 13:24:11.816 EET [656709] DETAIL:  Key (rental_id)=(2) already exists.
2023-02-21 13:24:11.816 EET [656709] CONTEXT:  COPY rental, line 1
2023-02-21 13:24:11.816 EET [656709] STATEMENT:  COPY public.rental (rental_id, rental_date, inventory_id, customer_id, return_date, staff_id, last_update) FROM stdin;
	
2023-02-21 13:24:11.817 EET [656709] ERROR:  duplicate key value violates unique constraint "staff_pkey"
2023-02-21 13:24:11.817 EET [656709] DETAIL:  Key (staff_id)=(1) already exists.
2023-02-21 13:24:11.817 EET [656709] CONTEXT:  COPY staff, line 1
2023-02-21 13:24:11.817 EET [656709] STATEMENT:  COPY public.staff (staff_id, first_name, last_name, address_id, email, store_id, active, username, password, last_update, picture) FROM stdin;
	
2023-02-21 13:24:11.817 EET [656709] ERROR:  duplicate key value violates unique constraint "store_pkey"
2023-02-21 13:24:11.817 EET [656709] DETAIL:  Key (store_id)=(1) already exists.
2023-02-21 13:24:11.817 EET [656709] CONTEXT:  COPY store, line 1
2023-02-21 13:24:11.817 EET [656709] STATEMENT:  COPY public.store (store_id, manager_staff_id, address_id, last_update) FROM stdin;
	
2023-02-21 13:24:11.871 EET [656709] ERROR:  multiple primary keys for table "actor" are not allowed
2023-02-21 13:24:11.871 EET [656709] STATEMENT:  ALTER TABLE ONLY public.actor
	    ADD CONSTRAINT actor_pkey PRIMARY KEY (actor_id);
	
	
	
2023-02-21 13:24:11.872 EET [656709] ERROR:  multiple primary keys for table "address" are not allowed
2023-02-21 13:24:11.872 EET [656709] STATEMENT:  ALTER TABLE ONLY public.address
	    ADD CONSTRAINT address_pkey PRIMARY KEY (address_id);
	
	
	
2023-02-21 13:24:11.873 EET [656709] ERROR:  multiple primary keys for table "category" are not allowed
2023-02-21 13:24:11.873 EET [656709] STATEMENT:  ALTER TABLE ONLY public.category
	    ADD CONSTRAINT category_pkey PRIMARY KEY (category_id);
	
	
	
2023-02-21 13:24:11.874 EET [656709] ERROR:  multiple primary keys for table "city" are not allowed
2023-02-21 13:24:11.874 EET [656709] STATEMENT:  ALTER TABLE ONLY public.city
	    ADD CONSTRAINT city_pkey PRIMARY KEY (city_id);
	
	
	
2023-02-21 13:24:11.874 EET [656709] ERROR:  multiple primary keys for table "country" are not allowed
2023-02-21 13:24:11.874 EET [656709] STATEMENT:  ALTER TABLE ONLY public.country
	    ADD CONSTRAINT country_pkey PRIMARY KEY (country_id);
	
	
	
2023-02-21 13:24:11.875 EET [656709] ERROR:  multiple primary keys for table "customer" are not allowed
2023-02-21 13:24:11.875 EET [656709] STATEMENT:  ALTER TABLE ONLY public.customer
	    ADD CONSTRAINT customer_pkey PRIMARY KEY (customer_id);
	
	
	
2023-02-21 13:24:11.875 EET [656709] ERROR:  multiple primary keys for table "film_actor" are not allowed
2023-02-21 13:24:11.875 EET [656709] STATEMENT:  ALTER TABLE ONLY public.film_actor
	    ADD CONSTRAINT film_actor_pkey PRIMARY KEY (actor_id, film_id);
	
	
	
2023-02-21 13:24:11.876 EET [656709] ERROR:  multiple primary keys for table "film_category" are not allowed
2023-02-21 13:24:11.876 EET [656709] STATEMENT:  ALTER TABLE ONLY public.film_category
	    ADD CONSTRAINT film_category_pkey PRIMARY KEY (film_id, category_id);
	
	
	
2023-02-21 13:24:11.877 EET [656709] ERROR:  multiple primary keys for table "film" are not allowed
2023-02-21 13:24:11.877 EET [656709] STATEMENT:  ALTER TABLE ONLY public.film
	    ADD CONSTRAINT film_pkey PRIMARY KEY (film_id);
	
	
	
2023-02-21 13:24:11.877 EET [656709] ERROR:  multiple primary keys for table "inventory" are not allowed
2023-02-21 13:24:11.877 EET [656709] STATEMENT:  ALTER TABLE ONLY public.inventory
	    ADD CONSTRAINT inventory_pkey PRIMARY KEY (inventory_id);
	
	
	
2023-02-21 13:24:11.878 EET [656709] ERROR:  multiple primary keys for table "language" are not allowed
2023-02-21 13:24:11.878 EET [656709] STATEMENT:  ALTER TABLE ONLY public.language
	    ADD CONSTRAINT language_pkey PRIMARY KEY (language_id);
	
	
	
2023-02-21 13:24:11.879 EET [656709] ERROR:  multiple primary keys for table "payment" are not allowed
2023-02-21 13:24:11.879 EET [656709] STATEMENT:  ALTER TABLE ONLY public.payment
	    ADD CONSTRAINT payment_pkey PRIMARY KEY (payment_id);
	
	
	
2023-02-21 13:24:11.879 EET [656709] ERROR:  multiple primary keys for table "rental" are not allowed
2023-02-21 13:24:11.879 EET [656709] STATEMENT:  ALTER TABLE ONLY public.rental
	    ADD CONSTRAINT rental_pkey PRIMARY KEY (rental_id);
	
	
	
2023-02-21 13:24:11.880 EET [656709] ERROR:  multiple primary keys for table "staff" are not allowed
2023-02-21 13:24:11.880 EET [656709] STATEMENT:  ALTER TABLE ONLY public.staff
	    ADD CONSTRAINT staff_pkey PRIMARY KEY (staff_id);
	
	
	
2023-02-21 13:24:11.881 EET [656709] ERROR:  multiple primary keys for table "store" are not allowed
2023-02-21 13:24:11.881 EET [656709] STATEMENT:  ALTER TABLE ONLY public.store
	    ADD CONSTRAINT store_pkey PRIMARY KEY (store_id);
	
	
	
2023-02-21 13:24:11.881 EET [656709] ERROR:  relation "film_fulltext_idx" already exists
2023-02-21 13:24:11.881 EET [656709] STATEMENT:  CREATE INDEX film_fulltext_idx ON public.film USING gist (fulltext);
	
	
	
2023-02-21 13:24:11.882 EET [656709] ERROR:  relation "idx_actor_last_name" already exists
2023-02-21 13:24:11.882 EET [656709] STATEMENT:  CREATE INDEX idx_actor_last_name ON public.actor USING btree (last_name);
	
	
	
2023-02-21 13:24:11.883 EET [656709] ERROR:  relation "idx_fk_address_id" already exists
2023-02-21 13:24:11.883 EET [656709] STATEMENT:  CREATE INDEX idx_fk_address_id ON public.customer USING btree (address_id);
	
	
	
2023-02-21 13:24:11.883 EET [656709] ERROR:  relation "idx_fk_city_id" already exists
2023-02-21 13:24:11.883 EET [656709] STATEMENT:  CREATE INDEX idx_fk_city_id ON public.address USING btree (city_id);
	
	
	
2023-02-21 13:24:11.884 EET [656709] ERROR:  relation "idx_fk_country_id" already exists
2023-02-21 13:24:11.884 EET [656709] STATEMENT:  CREATE INDEX idx_fk_country_id ON public.city USING btree (country_id);
	
	
	
2023-02-21 13:24:11.885 EET [656709] ERROR:  relation "idx_fk_customer_id" already exists
2023-02-21 13:24:11.885 EET [656709] STATEMENT:  CREATE INDEX idx_fk_customer_id ON public.payment USING btree (customer_id);
	
	
	
2023-02-21 13:24:11.885 EET [656709] ERROR:  relation "idx_fk_film_id" already exists
2023-02-21 13:24:11.885 EET [656709] STATEMENT:  CREATE INDEX idx_fk_film_id ON public.film_actor USING btree (film_id);
	
	
	
2023-02-21 13:24:11.886 EET [656709] ERROR:  relation "idx_fk_inventory_id" already exists
2023-02-21 13:24:11.886 EET [656709] STATEMENT:  CREATE INDEX idx_fk_inventory_id ON public.rental USING btree (inventory_id);
	
	
	
2023-02-21 13:24:11.886 EET [656709] ERROR:  relation "idx_fk_language_id" already exists
2023-02-21 13:24:11.886 EET [656709] STATEMENT:  CREATE INDEX idx_fk_language_id ON public.film USING btree (language_id);
	
	
	
2023-02-21 13:24:11.887 EET [656709] ERROR:  relation "idx_fk_rental_id" already exists
2023-02-21 13:24:11.887 EET [656709] STATEMENT:  CREATE INDEX idx_fk_rental_id ON public.payment USING btree (rental_id);
	
	
	
2023-02-21 13:24:11.888 EET [656709] ERROR:  relation "idx_fk_staff_id" already exists
2023-02-21 13:24:11.888 EET [656709] STATEMENT:  CREATE INDEX idx_fk_staff_id ON public.payment USING btree (staff_id);
	
	
	
2023-02-21 13:24:11.888 EET [656709] ERROR:  relation "idx_fk_store_id" already exists
2023-02-21 13:24:11.888 EET [656709] STATEMENT:  CREATE INDEX idx_fk_store_id ON public.customer USING btree (store_id);
	
	
	
2023-02-21 13:24:11.889 EET [656709] ERROR:  relation "idx_last_name" already exists
2023-02-21 13:24:11.889 EET [656709] STATEMENT:  CREATE INDEX idx_last_name ON public.customer USING btree (last_name);
	
	
	
2023-02-21 13:24:11.889 EET [656709] ERROR:  relation "idx_store_id_film_id" already exists
2023-02-21 13:24:11.889 EET [656709] STATEMENT:  CREATE INDEX idx_store_id_film_id ON public.inventory USING btree (store_id, film_id);
	
	
	
2023-02-21 13:24:11.890 EET [656709] ERROR:  relation "idx_title" already exists
2023-02-21 13:24:11.890 EET [656709] STATEMENT:  CREATE INDEX idx_title ON public.film USING btree (title);
	
	
	
2023-02-21 13:24:11.890 EET [656709] ERROR:  relation "idx_unq_manager_staff_id" already exists
2023-02-21 13:24:11.890 EET [656709] STATEMENT:  CREATE UNIQUE INDEX idx_unq_manager_staff_id ON public.store USING btree (manager_staff_id);
	
	
	
2023-02-21 13:24:11.891 EET [656709] ERROR:  relation "idx_unq_rental_rental_date_inventory_id_customer_id" already exists
2023-02-21 13:24:11.891 EET [656709] STATEMENT:  CREATE UNIQUE INDEX idx_unq_rental_rental_date_inventory_id_customer_id ON public.rental USING btree (rental_date, inventory_id, customer_id);
	
	
	
2023-02-21 13:24:11.891 EET [656709] ERROR:  trigger "film_fulltext_trigger" for relation "film" already exists
2023-02-21 13:24:11.891 EET [656709] STATEMENT:  CREATE TRIGGER film_fulltext_trigger BEFORE INSERT OR UPDATE ON public.film FOR EACH ROW EXECUTE PROCEDURE tsvector_update_trigger('fulltext', 'pg_catalog.english', 'title', 'description');
	
	
	
2023-02-21 13:24:11.892 EET [656709] ERROR:  trigger "last_updated" for relation "actor" already exists
2023-02-21 13:24:11.892 EET [656709] STATEMENT:  CREATE TRIGGER last_updated BEFORE UPDATE ON public.actor FOR EACH ROW EXECUTE PROCEDURE public.last_updated();
	
	
	
2023-02-21 13:24:11.892 EET [656709] ERROR:  trigger "last_updated" for relation "address" already exists
2023-02-21 13:24:11.892 EET [656709] STATEMENT:  CREATE TRIGGER last_updated BEFORE UPDATE ON public.address FOR EACH ROW EXECUTE PROCEDURE public.last_updated();
	
	
	
2023-02-21 13:24:11.892 EET [656709] ERROR:  trigger "last_updated" for relation "category" already exists
2023-02-21 13:24:11.892 EET [656709] STATEMENT:  CREATE TRIGGER last_updated BEFORE UPDATE ON public.category FOR EACH ROW EXECUTE PROCEDURE public.last_updated();
	
	
	
2023-02-21 13:24:11.893 EET [656709] ERROR:  trigger "last_updated" for relation "city" already exists
2023-02-21 13:24:11.893 EET [656709] STATEMENT:  CREATE TRIGGER last_updated BEFORE UPDATE ON public.city FOR EACH ROW EXECUTE PROCEDURE public.last_updated();
	
	
	
2023-02-21 13:24:11.893 EET [656709] ERROR:  trigger "last_updated" for relation "country" already exists
2023-02-21 13:24:11.893 EET [656709] STATEMENT:  CREATE TRIGGER last_updated BEFORE UPDATE ON public.country FOR EACH ROW EXECUTE PROCEDURE public.last_updated();
	
	
	
2023-02-21 13:24:11.893 EET [656709] ERROR:  trigger "last_updated" for relation "customer" already exists
2023-02-21 13:24:11.893 EET [656709] STATEMENT:  CREATE TRIGGER last_updated BEFORE UPDATE ON public.customer FOR EACH ROW EXECUTE PROCEDURE public.last_updated();
	
	
	
2023-02-21 13:24:11.894 EET [656709] ERROR:  trigger "last_updated" for relation "film" already exists
2023-02-21 13:24:11.894 EET [656709] STATEMENT:  CREATE TRIGGER last_updated BEFORE UPDATE ON public.film FOR EACH ROW EXECUTE PROCEDURE public.last_updated();
	
	
	
2023-02-21 13:24:11.894 EET [656709] ERROR:  trigger "last_updated" for relation "film_actor" already exists
2023-02-21 13:24:11.894 EET [656709] STATEMENT:  CREATE TRIGGER last_updated BEFORE UPDATE ON public.film_actor FOR EACH ROW EXECUTE PROCEDURE public.last_updated();
	
	
	
2023-02-21 13:24:11.895 EET [656709] ERROR:  trigger "last_updated" for relation "film_category" already exists
2023-02-21 13:24:11.895 EET [656709] STATEMENT:  CREATE TRIGGER last_updated BEFORE UPDATE ON public.film_category FOR EACH ROW EXECUTE PROCEDURE public.last_updated();
	
	
	
2023-02-21 13:24:11.895 EET [656709] ERROR:  trigger "last_updated" for relation "inventory" already exists
2023-02-21 13:24:11.895 EET [656709] STATEMENT:  CREATE TRIGGER last_updated BEFORE UPDATE ON public.inventory FOR EACH ROW EXECUTE PROCEDURE public.last_updated();
	
	
	
2023-02-21 13:24:11.896 EET [656709] ERROR:  trigger "last_updated" for relation "language" already exists
2023-02-21 13:24:11.896 EET [656709] STATEMENT:  CREATE TRIGGER last_updated BEFORE UPDATE ON public.language FOR EACH ROW EXECUTE PROCEDURE public.last_updated();
	
	
	
2023-02-21 13:24:11.896 EET [656709] ERROR:  trigger "last_updated" for relation "rental" already exists
2023-02-21 13:24:11.896 EET [656709] STATEMENT:  CREATE TRIGGER last_updated BEFORE UPDATE ON public.rental FOR EACH ROW EXECUTE PROCEDURE public.last_updated();
	
	
	
2023-02-21 13:24:11.896 EET [656709] ERROR:  trigger "last_updated" for relation "staff" already exists
2023-02-21 13:24:11.896 EET [656709] STATEMENT:  CREATE TRIGGER last_updated BEFORE UPDATE ON public.staff FOR EACH ROW EXECUTE PROCEDURE public.last_updated();
	
	
	
2023-02-21 13:24:11.897 EET [656709] ERROR:  trigger "last_updated" for relation "store" already exists
2023-02-21 13:24:11.897 EET [656709] STATEMENT:  CREATE TRIGGER last_updated BEFORE UPDATE ON public.store FOR EACH ROW EXECUTE PROCEDURE public.last_updated();
	
	
	
2023-02-21 13:24:11.897 EET [656709] ERROR:  constraint "customer_address_id_fkey" for relation "customer" already exists
2023-02-21 13:24:11.897 EET [656709] STATEMENT:  ALTER TABLE ONLY public.customer
	    ADD CONSTRAINT customer_address_id_fkey FOREIGN KEY (address_id) REFERENCES public.address(address_id) ON UPDATE CASCADE ON DELETE RESTRICT;
	
	
	
2023-02-21 13:24:11.898 EET [656709] ERROR:  constraint "film_actor_actor_id_fkey" for relation "film_actor" already exists
2023-02-21 13:24:11.898 EET [656709] STATEMENT:  ALTER TABLE ONLY public.film_actor
	    ADD CONSTRAINT film_actor_actor_id_fkey FOREIGN KEY (actor_id) REFERENCES public.actor(actor_id) ON UPDATE CASCADE ON DELETE RESTRICT;
	
	
	
2023-02-21 13:24:11.899 EET [656709] ERROR:  constraint "film_actor_film_id_fkey" for relation "film_actor" already exists
2023-02-21 13:24:11.899 EET [656709] STATEMENT:  ALTER TABLE ONLY public.film_actor
	    ADD CONSTRAINT film_actor_film_id_fkey FOREIGN KEY (film_id) REFERENCES public.film(film_id) ON UPDATE CASCADE ON DELETE RESTRICT;
	
	
	
2023-02-21 13:24:11.899 EET [656709] ERROR:  constraint "film_category_category_id_fkey" for relation "film_category" already exists
2023-02-21 13:24:11.899 EET [656709] STATEMENT:  ALTER TABLE ONLY public.film_category
	    ADD CONSTRAINT film_category_category_id_fkey FOREIGN KEY (category_id) REFERENCES public.category(category_id) ON UPDATE CASCADE ON DELETE RESTRICT;
	
	
	
2023-02-21 13:24:11.900 EET [656709] ERROR:  constraint "film_category_film_id_fkey" for relation "film_category" already exists
2023-02-21 13:24:11.900 EET [656709] STATEMENT:  ALTER TABLE ONLY public.film_category
	    ADD CONSTRAINT film_category_film_id_fkey FOREIGN KEY (film_id) REFERENCES public.film(film_id) ON UPDATE CASCADE ON DELETE RESTRICT;
	
	
	
2023-02-21 13:24:11.900 EET [656709] ERROR:  constraint "film_language_id_fkey" for relation "film" already exists
2023-02-21 13:24:11.900 EET [656709] STATEMENT:  ALTER TABLE ONLY public.film
	    ADD CONSTRAINT film_language_id_fkey FOREIGN KEY (language_id) REFERENCES public.language(language_id) ON UPDATE CASCADE ON DELETE RESTRICT;
	
	
	
2023-02-21 13:24:11.901 EET [656709] ERROR:  constraint "fk_address_city" for relation "address" already exists
2023-02-21 13:24:11.901 EET [656709] STATEMENT:  ALTER TABLE ONLY public.address
	    ADD CONSTRAINT fk_address_city FOREIGN KEY (city_id) REFERENCES public.city(city_id);
	
	
	
2023-02-21 13:24:11.901 EET [656709] ERROR:  constraint "fk_city" for relation "city" already exists
2023-02-21 13:24:11.901 EET [656709] STATEMENT:  ALTER TABLE ONLY public.city
	    ADD CONSTRAINT fk_city FOREIGN KEY (country_id) REFERENCES public.country(country_id);
	
	
	
2023-02-21 13:24:11.902 EET [656709] ERROR:  constraint "inventory_film_id_fkey" for relation "inventory" already exists
2023-02-21 13:24:11.902 EET [656709] STATEMENT:  ALTER TABLE ONLY public.inventory
	    ADD CONSTRAINT inventory_film_id_fkey FOREIGN KEY (film_id) REFERENCES public.film(film_id) ON UPDATE CASCADE ON DELETE RESTRICT;
	
	
	
2023-02-21 13:24:11.903 EET [656709] ERROR:  constraint "payment_customer_id_fkey" for relation "payment" already exists
2023-02-21 13:24:11.903 EET [656709] STATEMENT:  ALTER TABLE ONLY public.payment
	    ADD CONSTRAINT payment_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES public.customer(customer_id) ON UPDATE CASCADE ON DELETE RESTRICT;
	
	
	
2023-02-21 13:24:11.903 EET [656709] ERROR:  constraint "payment_rental_id_fkey" for relation "payment" already exists
2023-02-21 13:24:11.903 EET [656709] STATEMENT:  ALTER TABLE ONLY public.payment
	    ADD CONSTRAINT payment_rental_id_fkey FOREIGN KEY (rental_id) REFERENCES public.rental(rental_id) ON UPDATE CASCADE ON DELETE SET NULL;
	
	
	
2023-02-21 13:24:11.904 EET [656709] ERROR:  constraint "payment_staff_id_fkey" for relation "payment" already exists
2023-02-21 13:24:11.904 EET [656709] STATEMENT:  ALTER TABLE ONLY public.payment
	    ADD CONSTRAINT payment_staff_id_fkey FOREIGN KEY (staff_id) REFERENCES public.staff(staff_id) ON UPDATE CASCADE ON DELETE RESTRICT;
	
	
	
2023-02-21 13:24:11.904 EET [656709] ERROR:  constraint "rental_customer_id_fkey" for relation "rental" already exists
2023-02-21 13:24:11.904 EET [656709] STATEMENT:  ALTER TABLE ONLY public.rental
	    ADD CONSTRAINT rental_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES public.customer(customer_id) ON UPDATE CASCADE ON DELETE RESTRICT;
	
	
	
2023-02-21 13:24:11.905 EET [656709] ERROR:  constraint "rental_inventory_id_fkey" for relation "rental" already exists
2023-02-21 13:24:11.905 EET [656709] STATEMENT:  ALTER TABLE ONLY public.rental
	    ADD CONSTRAINT rental_inventory_id_fkey FOREIGN KEY (inventory_id) REFERENCES public.inventory(inventory_id) ON UPDATE CASCADE ON DELETE RESTRICT;
	
	
	
2023-02-21 13:24:11.905 EET [656709] ERROR:  constraint "rental_staff_id_key" for relation "rental" already exists
2023-02-21 13:24:11.905 EET [656709] STATEMENT:  ALTER TABLE ONLY public.rental
	    ADD CONSTRAINT rental_staff_id_key FOREIGN KEY (staff_id) REFERENCES public.staff(staff_id);
	
	
	
2023-02-21 13:24:11.906 EET [656709] ERROR:  constraint "staff_address_id_fkey" for relation "staff" already exists
2023-02-21 13:24:11.906 EET [656709] STATEMENT:  ALTER TABLE ONLY public.staff
	    ADD CONSTRAINT staff_address_id_fkey FOREIGN KEY (address_id) REFERENCES public.address(address_id) ON UPDATE CASCADE ON DELETE RESTRICT;
	
	
	
2023-02-21 13:24:11.907 EET [656709] ERROR:  constraint "store_address_id_fkey" for relation "store" already exists
2023-02-21 13:24:11.907 EET [656709] STATEMENT:  ALTER TABLE ONLY public.store
	    ADD CONSTRAINT store_address_id_fkey FOREIGN KEY (address_id) REFERENCES public.address(address_id) ON UPDATE CASCADE ON DELETE RESTRICT;
	
	
	
2023-02-21 13:24:11.907 EET [656709] ERROR:  constraint "store_manager_staff_id_fkey" for relation "store" already exists
2023-02-21 13:24:11.907 EET [656709] STATEMENT:  ALTER TABLE ONLY public.store
	    ADD CONSTRAINT store_manager_staff_id_fkey FOREIGN KEY (manager_staff_id) REFERENCES public.staff(staff_id) ON UPDATE CASCADE ON DELETE RESTRICT;
	
	
	
2023-02-21 13:25:50.125 EET [656843] ERROR:  relation "dvdrental" does not exist at character 15
2023-02-21 13:25:50.125 EET [656843] STATEMENT:  SELECT * FROM dvdrental;
2023-02-21 13:28:14.245 EET [657054] FATAL:  database "bob" does not exist
2023-02-21 13:28:42.199 EET [657076] FATAL:  database "bob" does not exist
2023-02-21 13:29:32.929 EET [657201] ERROR:  relation "dvdrental" does not exist at character 15
2023-02-21 13:29:32.929 EET [657201] STATEMENT:  SELECT * FROM dvdrental;
2023-02-21 13:31:56.670 EET [657201] ERROR:  syntax error at or near "*" at character 6
2023-02-21 13:31:56.670 EET [657201] STATEMENT:  SHOW * FROM dvdrental;
2023-02-21 13:37:28.672 EET [657708] WARNING:  there is no transaction in progress
2023-02-21 13:40:15.556 EET [657708] WARNING:  there is no transaction in progress
2023-02-21 13:40:34.248 EET [658157] ERROR:  syntax error at or near "$" at character 1
2023-02-21 13:40:34.248 EET [658157] STATEMENT:  $engine2.url
2023-02-21 17:26:05.093 EET [670175] WARNING:  there is no transaction in progress
2023-02-21 17:30:09.200 EET [621933] PANIC:  could not open file "/home/javi/code/popo/pg_data/global/pg_control": No such file or directory
2023-02-21 17:30:09.644 EET [621931] LOG:  checkpointer process (PID 621933) was terminated by signal 6: Aborted
2023-02-21 17:30:09.644 EET [621931] LOG:  terminating any other active server processes
2023-02-21 17:30:09.644 EET [621936] WARNING:  terminating connection because of crash of another server process
2023-02-21 17:30:09.644 EET [621936] DETAIL:  The postmaster has commanded this server process to roll back the current transaction and exit, because another server process exited abnormally and possibly corrupted shared memory.
2023-02-21 17:30:09.644 EET [621936] HINT:  In a moment you should be able to reconnect to the database and repeat your command.
2023-02-21 17:30:09.644 EET [664704] WARNING:  terminating connection because of crash of another server process
2023-02-21 17:30:09.644 EET [664704] DETAIL:  The postmaster has commanded this server process to roll back the current transaction and exit, because another server process exited abnormally and possibly corrupted shared memory.
2023-02-21 17:30:09.644 EET [664704] HINT:  In a moment you should be able to reconnect to the database and repeat your command.
2023-02-21 17:30:09.646 EET [621931] LOG:  all server processes terminated; reinitializing
2023-02-21 17:30:09.675 EET [621931] FATAL:  could not stat data directory "/home/javi/code/popo/pg_data": No such file or directory
2023-02-21 17:30:09.676 EET [621931] LOG:  database system is shut down
